# 智文的前端小站

## 一、HTML

  ### H5新标签

1. header 表示头部
2. nav 表示导航
3. article 表示文章主体
4. aside 表示和页面主要内容有关，但不是页面的一部分，经常表示一个相关链接
5. footer 表示底部
6. audio 音频标签
7. video 视频标签

h5 新标签提供了更好的语义化支持

  ### meta标签

meta：文档级元数据元素，提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词

#### 属性

- name：

  - description 用于网站内容的描述，告诉搜索引擎网站的主要内容

    ```html
    <meta name="description" content="网站的描述">
    ```

  - keywords 告诉搜索引擎网页的关键字

    ```html
    <meta name="keywords" content="网站的关键字">
    ```

  - viewport 指定移动端的窗口

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ```

- http-equiv：

  - content-type 设定网页字符集

    ```html
    <meta charset="utf-8">
    ```

  - X-UA-Compatible 用于告知浏览器以何种版本来渲染页面

    ```html
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    ```

  - cache-control 指导浏览器如何缓存某个响应以及缓存多长时间

    ```html
    <meta http-equiv="cache-control" content="no-cache">
    ```

    - no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。
    - no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）
    - public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果
    - private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）
    - maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。

## 二、CSS

### 选择器

#### 选择器列表

将多个选择器使用逗号组合起来形成选择器列表，当选择器列表中有选择器无效（语法错误）时，整个列表都会被忽略

#### 选择器种类

1. 类型选择器

   ```css
   h1{}
   ```

2. 类选择器

   ```css
   .box1{}   
   div.box1{}   /*div中所有box1类*/
   ```

3. ID选择器

   ```css
   #btn{}
   ```

4. 属性选择器

   ```css
   [title='mytitle']{}
   ```

5. 关系选择器

   1. 后代选择器

      ```css
      ul li{}
      ```

   2. 子代选择器

      ```css
      article > p{}
      ```

   3. 相邻兄弟选择器

      ```css
      h1 + p{}
      ```

   4. 通用兄弟选择器

      ```css
      h1 ~ p{}
      ```

6. 伪类选择器

   1. :checked

      ```css
      input:checked{}   /*选择所有被选中的input标签*/
      ```

   2. :default

      ```css
      input:default{}   /*选择所有默认的input*/
      ```

   3. :focus

      ```css
      input:focus{}   /*选择获得焦点的input*/
      ```

   4. :disabled

      ```css
      input:disabled{}   /*选择所有禁用的input*/
      ```

   5. :enabled

      ```css
      input:enabled{}   /*选择所有启用的input*/
      ```

   6. :first-child

      ```css
      p:first-child{}   /*选择每一组p标签中第一个p标签（第一个子代元素必须是p，否则不匹配）*/
      ```

   7. :first-of-type

      ```css
      p:first-of-type{}   /*选择一组p标签兄弟中的第一个p标签（不需要考虑父元素的第一个子代元素）*/
      ```

   8. :nth-child
   
7. 伪元素选择器

   1. ::before

      ```css
      div::before{
      	content: ">";   /*创建一个伪元素，作为该元素的第一个子元素，默认为行内元素*/
      }
      ```

   2. ::after

      ```css
      div::after{
        content: "<";   /*创建一个伪元素，作为已选中元素的最后一个子元素，默认是行内元素*/
      }
      ```

8. 通配选择器

   ```css
   *{
   	/*选择所有元素*/
   }
   ```


### 选择器权重

不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。

一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：

1. **千位**： 如果声明在 [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style) 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。
2. **百位**： 选择器中包含ID选择器则该位得一分。
3. **十位**： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。
4. **个位**：选择器中包含元素、伪元素选择器则该位得一分。

> 通用选择器 (`*`)，组合符 (`+`, `>`, `~`, ' ')，和否定伪类 (`:not`) 不会影响优先级。
>
> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。

`!important` 能覆盖所有规则

### 盒模型

#### 盒模型

组成一个块级盒模型需要：

- Content box：这个区域是用来显示内容，大小可以通过设置 [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height)。
- Padding box：包围在内容区域外部的空白区域； 大小通过 [`padding`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding) 相关属性设置。
- Border box：边框盒包裹内容和内边距。大小通过 [`border`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/border) 相关属性设置。
- Margin box：这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 [`margin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin) 相关属性设置。

当设置width和height时，设置的是content box，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。

元素的总宽度应该这样计算：

元素总宽度 = 宽度 + 左内边距 + 右内边距 + 左边框 + 右边框 + 左外边距 + 右外边距

元素的总高度应该这样计算：

元素总高度 = 高度 + 上内边距 + 下内边距 + 上边框 + 下边框 + 上外边距 + 下外边距

#### 外边距

外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。

##### 外边距折叠

如果有两个外边距相接的元素，这些外边距将==合并为一个外边距==，即最大的单个外边距的大小。

#### 内联盒子

对于内联盒子（内联元素），设置==宽度和高度会被忽略==，但==内边距，外边距和边框生效==，但它们不会改变其他内容与内联盒子的关系，因此==内边距和边框会与段落中的其他单词重叠==。解决方法：display: inline-block;

### BFC，.clearfix 清除塌陷

块级格式化上下文（Block Formatting Context, BFC），是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

#### 创建BFC

- 根元素（html）
- 浮动元素（元素的 float 不是 none）
- 绝对定位元素（display: absolute 或 display: fixed）
- 行内块元素（display: inline-block）
- `display` 值为 `flow-root` 的元素
- 表格单元格（元素的 `display` 为 `table-cell`，HTML 表格单元格默认为该值）
- 表格标题（元素的`display`为 `table-caption`，HTML 表格标题默认为该值）
- 匿名表格单元格元素（元素的`display`为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是 HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）
- overflow 不为 visible 的元素
- 弹性元素（flex 的直接子元素）
- 网格元素（gird 的直接子元素）

#### BFC的作用

- 父元素高度塌陷

  当子元素高度大于父元素，且子元素开启浮动后，由于子元素脱离了文档流，会导致父元素高度塌陷。

  ###### 解决方法

  - 改变父元素的 `overflow` 值，开启父元素的BFC，这时父元素会变成一个迷你布局，将包含浮动的子元素

  - 开启父元素的 `display: flow-root` ，它可以创建无副作用的 BFC。关于值 `flow-root`的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的`<html>`元素） 的东西时，就能发现这个名字的意义了——即==创建一个上下文，里面将进行 [flow layout](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout)==（也就是文档流布局）。

  - 添加一个新的空元素把父元素撑开（会占用仅有的两个伪元素）

    ```css
    .clearfix::before,   /*在前面加一个空的伪元素，解决父子外边距合并问题*/
    .clearfix::after{
        content:'';
        display:table;
        clear:both;   /*清除浮动影响，确保这个空元素能在浮动元素下面*/
    }
    ```

- 外边距合并

  两个相邻的盒子的外边距会合并在一起（①父元素有 margin-top，子元素也有 margin-top，且没有边框，这时两个 margin-top 重叠在一起，会产生合并,导致子元素的外边距无法在父元素内，父子元素会贴在一起；②两个兄弟元素之间的外边距重叠在一起,取最大值）

  ###### 解决方法

  - 给父元素加上边框（会改变盒子大小）
  - 开启父元素 BFC
  - 使用 clearfix 类（在父元素前面加一个空的伪元素来隔开两个外边距）

### 浮动
### 定位
### em，rem，以及 rem 进行移动端布局

#### em 和 rem

- em：font-size-of-the-element，em 作为 font-size 的单位时，其代表父元素的字体大小，em 作为其他属性单位时，代表自身字体大小
- rem：font-size-of-the-root-element，rem 作用于非根元素时，相对于根元素字体大小；rem 作用于根元素字体大小时，相对于其出初始字体大小

#### rem 布局

由于 100vw 转换为设计图里的 750px，假设有一个 30px 需要转换，可以得出 30px / 750px = (x)vw / 100vw，即 x = (100 / 750) * 30 ，然而每次需要换算时都进行 `(100 / 设计图宽度) * 需要转换的px` 实在是太麻烦了，所以使用 rem 来确定转换关系。

##### 思路

==设置根元素大小为一个固定数值 * (100vw / 设计图宽度)，这样我们在进行计算时只需要除以那个固定数值（通常是 100）即可（单位是 rem）==，这时 1rem = 固定数值个设计图里的 px（100px）

rem 布局首先要操控根元素字体大小

```css
html{
    font-size: calc(100*100vw/750);
}
body{
  font-size:14px; /* 在这里把字体大小校正回来 */
}
```

这里是因为很多设计稿都是基于 iPhone6 来设计的，一般都是 750px（2 倍图，iPhone6 的设备宽度为 375px）所以除以  750 是为了在 iPhone6 设备下让 1rem 等于 100px。

```css
.menu li{
    display: table-cell;
    padding: .1rem .3rem;  /* 相当于10px 30px */
}
```



### 过渡和动画

#### 过渡

CSS 过渡 由简写属性`transition`定义是最好的方式，可以避免属性值列表长度不一，节省调试时间。

过渡的子属性有：

- `transition-property` 指定了哪些属性用于过渡，默认是 all
- `transition-duration` 指定了过渡的时长，可以为多个属性指定不同的时长，单位是 s 或者 ms
- `transition-timing-function` 指定了过渡的变化函数。默认是 ease
  - ease 先加速再减速
  - linear 线性匀速变化
  - ease-in 加速
  - ease-out 减速
  - steps() 指定分步执行过渡效果。接收两个参数，第一个是分成几步，第二个是 end 或 start，决定了每一阶段的开始还是结束时执行，默认是 end
  - cubic-bezier() 自定义运动曲线
- `transition-delay` 指定了执行的延迟时间，默认是 0

简写属性

​	简写属性要求两个时间中，第一个是持续时间，第二个是延迟时间

```css
div {
    transition: <property> <duration> <timing-function> <delay>;
}
```

过渡时必须是从数值向数值过渡，而==不能向 auto 过渡==。

#### 动画

在CSS中创建动画需要使用 `animation` 属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 `@keyframes` 规则实现。

动画的子属性有：

- `animation-name` 指定由 `@keyframes` 描述的关键帧名称

- `animation-duration` 设置动画的时长

- `animation-delay` 设置延时，即从元素加载完成到动画开始执行的时间

- `animation-direction` 设置动画执的方向

  - normal：默认值，从头到尾，从头到尾...
  - reverse：从尾到头，从尾到头...
  - alternate：从头到尾，从尾到头，从头到尾...
  - alternate-reverse：从尾到头，从头到尾，从尾到头...

- `animation-iteration-count` 设置动画重复次数，可以指定 infinite 无限循环动画

- `animation-play-state` 动画默认在结束时跳回开始状态，要想保持结束时的状态，使用这个属性

  ```css
  /*没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放。*/
  div {
      animation: spin 1s linear infinite;
      animation-play-state: paused;
  }
  
  div:hover {
    animation-play-state: running;
  }
  ```

- `animation-timing-function` 指定了动画的运动曲线

- `animation-fill-mode` 指定动画的填充模式

  - `none`：默认值，结束后回到元素原来的状态。
  - `forwards`：结束后让动画停留在结束状态 （to 的状态）。
  - `backwards`：结束后让动画回到第一帧的状态（from 的状态）。
  - `both`: 根据 animation-direction 轮流应用 forwards 和 backwards 规则。

动画的简写属性

```css
/*以下两种写法是等价的*/
div:hover {
  animation: 2s 1s rainbow linear 3 forwards normal;
}

div:hover {
  animation-name: rainbow;
  animation-duration: 2s;
  animation-timing-function: linear;
  animation-delay: 1s;
  animation-fill-mode: forwards;
  animation-direction: normal;
  animation-iteration-count: 3;
}
```

使用 @keyframes 定义动画关键帧

> ​	`0%`表示动画的第一时刻，`100%`表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：`from`和`to`。这两个都是可选的，若`from/0%`或`to/100%`未指定，则浏览器使用计算值开始或结束动画。

```css
/*该例中<p>元素由浏览器窗口右边滑至左边*/
p {
  animation: 3s slidein;
}

@keyframes slidein {
  from {
    margin-left: 100%;
    width: 300%;
  }

  to {
    margin-left: 0%;
    width: 100%;
  }
}
```



### 变形

变形是通过 CSS 来改变元素的形状或位置，变形==不会影响页面的布局==，使用 transform 来设置变形效果

使用  `transform-origin` 来设置变形原点，可选值：left，top...或X,Y值。默认为center

#### 平移

​	若使用百分比，百分比相对自己计算。（可以通过这一点来使元素居中）

- `translateX()` 沿着X轴平移

- `translateY()` 沿着Y轴平移

- `translateZ()` 沿着Z轴平移，数值越大，离人越近。但是默认情况下网页是不支持透视的（大小不变），想要看见效果必须==设置网页视距==

  ```css
  html{
  	/*设置网页的视距是800px（人眼距离网页的距离）*/
  	perspective: 800px;
  }
  ```

#### 旋转

​	需要设置视距来产生大小变化效果

- `rotateX()` 沿着X轴顺时针旋转，单位是 deg（度数）或 turn（几圈）
- `rotateY()` 沿着Y轴顺时针旋转
- `rotateZ()` 沿着Z轴顺时针旋转

#### 缩放

- `scale()` 对X和Y轴都进行缩放
- `scaleX()` 对X轴进行缩放
- `scaleY()` 对Y轴进行缩放
- `scaleZ()` 对Z轴进行缩放

### flex 布局

flex 布局即为弹性布局，为盒模型开启`display: flex`后，该盒模型就会成为 flex 容器，他其中的子元素会成为弹性元素。

flex 容器有两根轴，分别是默认的==水平主轴==（main axis）和与主轴垂直的==辅轴==（cross axis），弹性元素默认沿着主轴排列。

#### flex 容器的属性

- flex-direction 修改主轴方向，可选 `row` , `row-reverse` , `column` , `column-reverse`，默认为 `row`
- flex-wrap 修改是否换行，可选 `nowrap` , `wrap` , `wrap-reverse`，默认为 `nowrap`
- flex-flow 上面两个属性的简写，可以同时设定两个属性，默认为 `row nowrap`
- justify-content 定义了元素在主轴上的排列方式，可选 `flex-start` , `flex-end` , `center` , `space-around` , `space-between`
- align-items 定义了元素在辅轴上的排列方式，可选 `flex-start` , `flex-end` , `center` , `baseline` , `stretch`
- align-content 定义了多条辅轴（有换行时生效），可选 `flex-start` , `flex-end` , `center` , `space-between` , `space-around` , `stretch`

#### 弹性元素的属性

- order 定义元素的排列顺序，默认都是0，数值越小越靠前，`.item{order: 1}`会让这个元素排在为0的元素后面
- flex-grow 定义了有空余空间时元素的放大比例，默认是0，即不放大。如果所有元素的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个元素的`flex-grow`属性为2，其他元素都为1，则前者占据的剩余空间将比其他元素多一倍。
- flex-shrink 定义了空间不够时元素如何收缩，默认为1，即默认都会等比例缩小。如果一个元素的`flex-shrink`属性为0，其他元素都为1，则空间不足时，前者不缩小。负值对该属性无效。
- align-self 允许元素设定自己的辅轴对齐方式，默认为 `auto`，即继承父元素的 `align-items` 属性。该属性可能取6个值，除了 `auto`，其他都与 `align-items` 属性完全一致。

### grid 布局

网格布局将网页分隔成一个个网格，可以组合任意不同的网格。

使用 `display: grid` 布局的元素称为“容器（container）”，其中的子元素称为“项目（item）”。

注意：项目只能是容器的顶层子元素，不包含项目的子元素。Grid 布局只对项目生效。

#### 行，列，单元格和网格线

容器里面的水平区域称为"行"（row），垂直区域称为"列"（column）。

行和列的交叉区域，称为"单元格"（cell）。

划分网格的线，称为"网格线"（grid line）。水平网格线划分出行，垂直网格线划分出列。

正常情况下，`n`行有`n + 1`根水平网格线，`m`列有`m + 1`根垂直网格线，比如三行就有四根水平网格线。

#### 容器属性

**grid-template-columns 属性， grid-template-rows 属性**

- `grid-template-columns` 定义了容器有多少列，以及每一列的宽度
- `grid-template-rows` 定义了容器有多少行，以及每一行的高度

**重复，auto-fill 及 fr**

1. repeat

   ```css
   .container {
     display: grid;
     grid-template-columns: repeat(3, 33.33%);
     grid-template-rows: repeat(3, 33.33%);
   }
   ```

2. auto-fill

   有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用`auto-fill`关键字表示自动填充。

   ```css
   .container {
     display: grid;
     grid-template-columns: repeat(auto-fill, 100px);
   }
   ```

   上面代码表示每列宽度`100px`，然后自动填充，直到容器不能放置更多的列。

3. fr单位

   为了方便表示比例关系，网格布局提供了`fr`关键字（fraction 的缩写，意为"片段"）。如果两列的宽度分别为`1fr`和`2fr`，就表示后者是前者的两倍。

   `fr`可以与绝对长度的单位结合使用，这时会非常方便。

   ```css
   .container {
     display: grid;
     grid-template-columns: 150px 1fr 2fr;
   }
   ```

   上面代码表示，第一列的宽度为 150 像素，第二列的宽度是第三列的一半。

**grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性**

`grid-row-gap`属性设置行与行的间隔（行间距），`grid-column-gap`属性设置列与列的间隔（列间距）。

```css
.container {
  grid-row-gap: 20px;
  grid-column-gap: 20px;
}
```

上面代码中，`grid-row-gap`用于设置行间距，`grid-column-gap`用于设置列间距。

`grid-gap`属性是`grid-column-gap`和`grid-row-gap`的合并简写形式，语法如下。

```css
grid-gap: <grid-row-gap> <grid-column-gap>;
```

因此，上面一段 CSS 代码等同于下面的代码。

```css
.container {
  grid-gap: 20px 20px;
}
```

如果`grid-gap`省略了第二个值，浏览器认为第二个值等于第一个值。

> 根据最新标准，上面三个属性名的`grid-`前缀已经删除，`grid-column-gap`和`grid-row-gap`写成`column-gap`和`row-gap`，`grid-gap`写成`gap`。

**grid-template-areas 属性**

网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: 'a b c'
                       'd e f'
                       'g h i';
}
```

上面代码先划分出 9 个单元格，然后将其定名为`a`到`i`的九个区域，分别对应这九个单元格。

多个单元格合并成一个区域的写法如下。

```css
grid-template-areas: 'a a a'
                     'b b b'
                     'c c c';
```

上面代码将 9 个单元格分成`a`、`b`、`c`三个区域。

下面是一个布局实例。

```css
grid-template-areas: "header header header"
                     "main main sidebar"
                     "footer footer footer";
```

上面代码中，顶部是页眉区域`header`，底部是页脚区域`footer`，中间部分则为`main`和`sidebar`。

如果某些区域不需要利用，则使用"点"（`.`）表示。

```css
grid-template-areas: 'a . c'
                     'd . f'
                     'g . i';
```

上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。

**grid-auto-flow 属性**

划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即下图数字的顺序。

这个顺序由`grid-auto-flow`属性决定，默认值是`row`，即"先行后列"。也可以将它设成`column`，变成"先列后行"。

`grid-auto-flow`属性除了设置成`row`和`column`，还可以设成`row dense`和`column dense`。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。

**justify-items 属性， align-items 属性， place-items 属性**

`justify-items`属性设置单元格内容的水平位置（左中右），`align-items`属性设置单元格内容的垂直位置（上中下）。

```css
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
```

这两个属性的写法完全相同，都可以取下面这些值。

> - start：对齐单元格的起始边缘。
> - end：对齐单元格的结束边缘。
> - center：单元格内部居中。
> - stretch：拉伸，占满单元格的整个宽度（默认值）。

```css
.container {
  justify-items: start;
}
```

`place-items`属性是`align-items`属性和`justify-items`属性的合并简写形式。

```css
place-items: <align-items> <justify-items>;
```

下面是一个例子。

```css
place-items: start end;
```

如果省略第二个值，则浏览器认为与第一个值相等。

**justify-content 属性， align-content 属性， place-content 属性**

`justify-content`属性是==整个内容区域==在容器里面的水平位置（左中右），`align-content`属性是==整个内容区域==的垂直位置（上中下）。

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
```

`place-content`属性是`align-content`属性和`justify-content`属性的合并简写形式。

```css
place-content: <align-content> <justify-content>
```

下面是一个例子。

```css
place-content: space-around space-evenly;
```

如果省略第二个值，浏览器就会假定第二个值等于第一个值。

#### 项目属性

**grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性**

项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。

- `grid-column-start`属性：左边框所在的垂直网格线
- `grid-column-end`属性：右边框所在的垂直网格线
- `grid-row-start`属性：上边框所在的水平网格线
- `grid-row-end`属性：下边框所在的水平网格线

这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。

这四个属性的值还可以使用`span`关键字，表示"跨越"，即左右边框（上下边框）之间跨越多少个网格。

使用这四个属性，如果产生了项目的重叠，则使用`z-index`属性指定项目的重叠顺序。

**grid-column 属性， grid-row 属性**

`grid-column`属性是`grid-column-start`和`grid-column-end`的合并简写形式，`grid-row`属性是`grid-row-start`属性和`grid-row-end`的合并简写形式。

```css
.item {
  grid-column: <start-line> / <end-line>;
  grid-row: <start-line> / <end-line>;
}
```

下面是一个例子。

```css
.item-1 {
  grid-column: 1 / 3;
  grid-row: 1 / 2;
}
/* 等同于 */
.item-1 {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 1;
  grid-row-end: 2;
}
```

这两个属性之中，也可以使用`span`关键字，表示跨越多少个网格。

**grid-area 属性**

`grid-area`属性指定项目放在哪一个区域。

```css
.item-1 {
  grid-area: e;
}
```

`grid-area`属性还可用作`grid-row-start`、`grid-column-start`、`grid-row-end`、`grid-column-end`的合并简写形式，直接指定项目的位置。

```css
.item {
  grid-area: <row-start> / <column-start> / <row-end> / <column-end>;
}
```

下面是一个[例子](https://jsbin.com/duyafez/edit?css,output)。

```css
.item-1 {
  grid-area: 1 / 1 / 3 / 3;
}
```

**justify-self 属性， align-self 属性， place-self 属性**

`justify-self`属性设置单元格内容的水平位置（左中右），跟`justify-items`属性的用法完全一致，但只作用于单个项目。

`align-self`属性设置单元格内容的垂直位置（上中下），跟`align-items`属性的用法完全一致，也是只作用于单个项目。

```css
.item {
  justify-self: start | end | center | stretch;
  align-self: start | end | center | stretch;
}
```

这两个属性都可以取下面四个值。

- start：对齐单元格的起始边缘。
- end：对齐单元格的结束边缘。
- center：单元格内部居中。
- stretch：拉伸，占满单元格的整个宽度（默认值）。

#### 媒体查询

使用媒体查询来修改 grid 布局十分简单，只需要修改对应的 template-area

```css
@media (min-width: 500px) {
    .wrapper {
        grid-template-columns: repeat(9, 1fr);
        grid-template-areas:
          "hd hd hd hd   hd   hd   hd   hd   hd"
          "sd sd sd main main main main main main"
          "sd sd sd  ft  ft   ft   ft   ft   ft";
    }
}
@media (min-width: 700px) {
    .wrapper {
        grid-template-areas:
          "hd hd hd   hd   hd   hd   hd   hd hd"
          "sd sd main main main main main ft ft";
    }
}
```

## 三、JS

### 数据类型

JS中一共有 6 种简单数据类型和1种复杂数据类型

#### 简单数据类型

箭头后是 typeof 运算结果

- Number  -->  number
- String  -->  string
- Boolean  -->  boolean
- Undefined  -->  undefined
- Null -->  object(null表示空对象，所以不能用typeof判断null)
- Symbol  -->  symbol

#### 复杂数据类型

- Object  -->  object

### null 和 undefined



### 原型链
### 执行上下文（重点哟）

在js中一共有三种执行上下文（Execution Context），分别是全局上下文，函数上下文和eval上下文（==对象是没有上下文的==），每个上下文都有一个变量对象，保存了这个上下文中定义的全部变量和函数。

使用var声明的变量会被自动添加到最近的上下文活动对象

#### 上下文栈

在执行每一个上下文时，会将它推入执行上下文栈，该栈的栈底是全局上下文，每个上下文会在它所有代码执行完毕后销毁出栈，（函数每次执行都会产生一个函数上下文）

#### 执行上下文的创建阶段（以函数上下文为例）

1. 生成变量对象

   1. **检索当前上下文中的参数**。该过程生成 arguments 对象，并建立以形参变量名为属性名，形参变量值为属性值的属性；

   2. **检索当前上下文中的函数声明**。该过程建立以函数名为属性名，函数所在内存地址引用为属性值的属性；

   3. **检索当前上下文中的变量声明**。该过程建立以变量名为属性名，undefined 为属性值的属性。

   4. ```js
      function fn(){
        console.log('fn!!');
      }
      
      fn(); // fn!!
      
      var fn = 2;
      
      fn(); // TypeError: fn is not a function（fn = 2将函数覆盖了）
      ```

2. 建立作用域链

   每个函数保存了一个 [[scope]] 内部属性，它保存了函数上一层上下文到全局上下文的所有变量对象，==该属性在声明时已经确定==。

   当函数被调用时，会创建自己的执行上下文和变量对象，将该变量对象加入到 [[scope]] 的最前端，构成完整的作用域链。

   代码执行时的标识符解析会沿着该链向上查找，直到全局上下文

3. 确定 this 指向

   ==this 指向是在这时才确定的！只有在函数被调用，创建其上下文时才能确定 this==。

   分析 this 指向

   1. 全局上下文中`this`指向全局对象（window）
   2. 函数如果由对象调用，则指向该对象
   3. 如果该函数被独立调用，那么其内部的 `this` 指向 window（严格模式下指向 undefined）
   4. 构造函数中的`this`指向新创建的对象

   拓展：箭头函数的 this 指向

   箭头函数没有自己的 this，它会在创建时获取该上下文中的 this（==在声明时就确定了==）

   ```js
   var name = 'window'; 
   
   var A = {
      name: 'A',
      sayHello: () => {
         console.log(this.name)
      }
   }
   
   A.sayHello(); // 输出window，获取了上一层的全局上下文（对象没有上下文）
   ```

#### 执行上下文的执行阶段

这时变量对象变为活动对象，执行其中的代码，原先声明的对象会在这里赋值。

#### 执行上下文的销毁阶段

上下文出栈，变量对象等待被垃圾回收。	

### 闭包（closure）

初学者的最大痛点——闭包

##### 闭包是什么

在 JS 中，函数内部可以访问上层的作用域，但是上层的作用域（函数外部）无法访问内层的作用域。有些时候，我们想要在外部来访问函数内部的变量（或是将某些私有变量藏进函数执行上下文中），这时，我们可以在函数内部返回一个函数，通过这个里层函数来访问外层函数。

##### 怎么创建一个闭包

```js
// 在这里我们引用一个经典的例子，创建一个外部无法随意修改值的计数器
// 这里是全局上下文
function createCounter(){  // 外层函数，外层函数上下文
  let cnt = 0
  return function(){
		return ++cnt;  // 里层函数，里层函数上下文
  }
}

let counter = createCounter() // counter是里层函数
console.log(counter());  // 1
console.log(counter());  // 2
console.log(counter());  // 3
console.log(counter());  // 4
```

##### 原理（最好先看看我写的执行上下文相关的内容）

先介绍一下变量对象：==变量对象是与执行上下文相关的数据作用域，用于存储执行上下文中的变量和函数声明==。

我们为了不让外界随意修改cnt的值，创建了一个闭包，将想要藏起来的变量放进了外层函数上下文中（外层函数上下文的变量对象）。当外层函数执行完后，该上下文会被弹出上下文栈，其变量对象理应会因为没有被外界引用而被垃圾回收（gc），相信你也注意到了，只要我们==保存下来这个对变量对象的引用==，不就能避免这个变量对象被回收，继而保存下来cnt了吗？

但是变量对象怎么找到并保存呢，这里我们使用了一点小技巧，里层函数的作用域链头部（[[scope]] 的头部）不就正是上一层上下文的变量对象吗？所以==只要外层函数内定义了其他函数==，这个外层函数的变量对象就不会被垃圾回收（从道理上来讲，里层函数还可能会用到他呢）。只要我们能拿到外层函数里的一个函数，那么我们就能操作外层函数的变量对象。

再回头看这个例子，第 10 行执行了外层函数，创建了一个包含 cnt = 0 的变量对象，又定义并返回了里层函数给 counter 变量，以此保存下来了外层变量对象。当里层函数再执行时（`counter()`），自然是先去作用域链上找自身的变量对象有没有 cnt ，发现没有后再往上找到我们一直苦心想要保存下来的外层变量对象，发现正好有 cnt，即执行 ++cnt，使 cnt = 1。

##### 例子与分析

在阮一峰老师的笔记那里找了两个例子

一：

```js
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    return function(){
      return this.name;
    };
  }
};

alert(object.getNameFunc()());
```

二：

```js
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    var that = this;
    return function(){
      return that.name;
    };
  }
};

alert(object.getNameFunc()());
```

分析：

一：

先说结论："The Window"。这里外层函数（`getNameFunc`）是对象的属性，所以上下文栈应该是：里层函数 -> 外层函数 -> 全局（对象没有上下文）。`object.getNameFunc()()` 可以分解为`object.getNameFunc()` 和 `()`，即先执行外层函数，得到里层函数，再执行里层函数。当执行外层函数时，返回了里层函数，所以该代码可以理解为`里层函数()`，这里的里层函数不是 object 调用的，而是独立调用，所以 this 指向全局，即输出 "The Window"。

二：

二和一的区别是外层函数声明了 that 变量来保存外层函数的 this，再来分析`object.getNameFunc()()` ，执行外层函数时（`object.getNameFunc()`），由于是 object 调用，this 指向 object（这里是执行时才能分析出来的哦，定义时是不知道this指向的），所以 that 指向的也是object，保存在变量对象中，里层函数执行时，先找自身没有 that，随后找外层函数变量对象，发现有 that，指向了 object，于是 `that.name` 就是 `object.name` 了。

##### 感想

为什么大家一直觉得闭包很难呢，我觉得是因为对于闭包，不仅仅需要理解一个两个知识点，而是需要了解执行上下文，this 指向，垃圾回收，作用域链等知识，才能理解闭包的原理。所以我强烈建议把这些知识点都看过后，再来看看闭包。

### this 指向

看执行上下文，里面有写。

### 继承的实现
### 深拷贝和浅拷贝
### 事件循环机制

### ES6

#### let 和 const
#### 数组新方法
#### Set 和 Map

##### Set

Set 类似于数组，但是成员的值都是唯一的，没有重复。

###### 创建 Set

使用 Set 构造函数创建一个集合：

```js
const s = new Set([2, 3, 3, 4, 5, 3, 1])

for(let v of s){
  console.log(v)
}

// 1 2 3 4 5
```

Set 构造函数可以接收一个实现了 Iterable 接口的数据结构作为参数，用来初始化。

在 set 中，判断两个值是否相等使用算法“Same-value equality”，主要类似于 === 运算符，且 `NaN` 等于自身（每个 `set` 中只能添加一个 `NaN`）。

###### Set 的属性和方法

集合的属性：

- `Set.prototype.constructor` 指向集合的构造函数，默认是 Set 构造函数
- `Set.prototype.size` 返回集合的成员个数

集合的方法：

- `add(value)` 用来在集合中添加一个成员，返回集合本身
- `delete(value)` 用来在集合中删除一个成员，返回一个布尔值，代表删除是否成功
- `has(value)` 查看一个元素是否是集合的成员，返回一个布尔值
- `clear()` 清空集合，没有返回值

###### Set 的遍历

Set 实例有三个迭代器生成方法和一个遍历方法：

- `keys()` 返回键名的迭代器，由于集合键名和键值是一样的，所以这个方法和 `values()` 行为完全一致。
- `values()` 返回键值的迭代器
- `entries()` 返回键值对的迭代器
- `forEach()` 使用回调函数遍历每个成员

Set 的遍历顺序就是==插入顺序==，可以用来保存回调函数列表，调用时就能保证按照添加顺序调用。

```js
let set = new Set(['red', 'green', 'blue'])

for(let v of set.keys()){
  console.log(v)
}
// red
// green
// blue

for(let v of set.values()){
  console.log(v)
}
// red
// green
// blue

for(let i of set.entries()){
  console.log(i)
}

// ['red', 'red']
// ['green', 'green']
// ['blue', 'blue']

let s = new Set([1, 2, 3])

s.forEach((value, key) => {
	console.log(value * 2)
})

// 2
// 4
// 6
```

但是 `Set` 原生实现了迭代接口，所以可以直接使用 for...of 来遍历，省略 `vlues()`。

```js
let set = ['red', 'green', 'blue']

for(let item of set){
	console.log(item)
}

// red
// green
// blue
```

##### WeakSet

WeakSet 和 Set 类似，也是不能重复的值的集合，但是它和 Set 有两个区别：

1. WeakSet 的成员==只能是对象==，不能是其他类型的值
2. WeakSet 中的成员都是==弱引用==，不会阻止垃圾回收

由于弱集合中的成员可以被垃圾回收，所以内部成员数量取决于垃圾回收机制，是不可预测的。所以==弱集合不允许遍历==。

###### 构造函数与成员方法

- `add(value)`
- `delete(value)`
- `has(value)`

```js
let ws = new WeakSet([[1, 2], [3, 4]])
// {[1, 2], [3, 4]}

let obj = {}, foo = {}

ws.add(obj)
// {[1, 2], [3, 4], {}}
ws.has(obj)
// true
```

==注意：弱集合没有 size 属性==

##### Map

JS 中的对象本质上是键值对的集合，键名只能是字符串。而 ES6 引入的 Map 数据结构解决了只能使用字符串作为键名的问题，提供了“值——值”的对应结构。

```js
const map = new Map();
const obj = {
  p: 'Hello World!'
}

map.set(obj, 'content')
map.get(obj) // 'content'

map.has(obj) // true
map.delete(obj) // true
map.has(obj) // false
```

Map 构造函数也接受一个数组作为参数，该数组的==成员是一个个表示键值对的数组==。

```js
const map = new Map([['name', '张三'], ['age', 18]])

map.has('name') // true
map.get('name') // '张三'
```

只有对同一个对象的引用，Map 才会将其视为同一个键名：

```js
const map = new Map()

map.set(['a'], 42)
map.get(['a']) // undefined
```

###### 实例的属性和方法

属性：

- `size` 属性返回 Map 结构的成员总数

方法：

- `set(key, value)` 设置 `key` 对应的键值，返回整个 `Map` 结构。若该键已经有值了，会更新该值。
- `get(key)` 读取 `key` 对应的键值，若找不到，则返回 `undefined`。
- `has(key)` 返回一个布尔值，表示某个键是否在 Map 数据结构中。
- `delete(key)` 删除某个键，返回值为是布尔值，表示否删除成功。
- `clear()` 清空整个 `Map`，无返回值

###### 遍历方法

Map 实例有三个迭代器生成方法和一个遍历方法：

- `keys()` 返回键名的迭代器
- `values()` 返回键值的迭代器
- `entries()` 返回键值对的迭代器
- `forEach()` 使用回调函数遍历每个成员

Map 的==遍历顺序就是插入顺序==

```js
const map = new Map([
  ['F', 'no'],
  ['T', 'yes']
])

// 遍历键名
for (let key of map.keys()){
	console.log(key)
}
// 'F'
// 'T'

// 遍历键值
for (let val of map.values()){
  console.log(val)
}
// 'no'
// 'yes'

// 遍历键值对
for (let item of map.entries()){
  console.log(item[0], item[1])
}

// 或者使用解构赋值
for (let [key, value] of map.entries()){
  console.log(key, value)
}

// 'F' 'no'
// 'T' 'yes'

// forEach 遍历，等同于使用 entries() 遍历
map.forEach((value, key) => {
	console.log(key, value)
})
```

###### Map 与数组的转换

将 Map 转换为数组比较快速的方法是使用扩展运算符：

```js
const map = new Map([
  [1, 'one'],
  [2, 'two'],
  [3, 'three']
])

let keys = [...Map.keys()]
// [1, 2, 3]
let values = [...Map.values()]
// ['one', 'two', 'three']
let keyValues = [...Map.entries()]
// [[1, 'one'], [2, 'two'], [3, 'three']]
// 等价于
keyValues = [...Map]
// [[1, 'one'], [2, 'two'], [3, 'three']]
```

将数组传入 Map 的构造函数就可以转换为 Map 了。

###### Map 与对象的转换

如果 Map 的==所有键名都是字符串==，则可以转换为对象：

```js
function strMap2Obj(map){
  let obj = {}
  for (let [key, value] of map){
    obj[key] = value
  }
  return obj
}
```

对象转换为 Map：

```js
function obj2StrMap(obj){
  let map = new Map
  for(let key of obj.keys()){
    map.set(key, obj[key])
  }
  return map
}
```

###### Map 与 JSON 的转换

Map 转换为 JSON：

当 Map 的键名都是字符串时，可以将 Map 转换为对象，再转换为 JSON；

当 Map 的键名不全是字符串时，可以将 Map 转换为数组（[...map]），再转换为 JSON。



JSON 转换为 Map：

可以将 JSON 转换为对象，再转换为 Map

##### WeakMap

弱映射和映射（Map）结构类似，区别为：

1. 弱映射只接受对象作为键名（不能是 null）
2. 弱映射键名指向的对象不计入垃圾回收机制



应用：

若是想在对象上添加一些数据，但是不希望干扰垃圾回收机制时，可以选择弱映射



API 的区别：

1. 没有遍历方法
2. 无法清空（不能使用 `clear()`）

所以弱映射只有四个方法：`get()`，`set()`，`has()`，`delete()`。



#### rest 参数，扩展运算符

##### rest 参数

ES6 引入了 rest 参数（...变量名），用于获取函数多余的参数，这样就不需要 `arguments` 对象了。rest 参数搭配的变量是一个数组，多余的参数将放入其中。

```js
function add(...rest){
  let sum = 0
  for(let val of values){
    sum += val
  }
  return sum
}

add(2, 3, 5) // 10
```

##### 扩展运算符

扩展运算符时三个点（...），如同 rest 参数的逆运算，将数组转化为一个逗号分隔的参数序列

```js
...[1, 2, 3] // 1, 2, 3
```

应用：

1. 合并数组

   ```js
   let arr1 = [1, 2], arr2 = [3, 4]
   let arr = [...arr1, ...arr2]
   arr // [1, 2, 3, 4]
   ```

2. 与解构赋值结合使用

   ```js
   const [first, ...rest] = [1, 2, 3, 4]
   first // 1
   rest // [2, 3, 4]
   ```

3. 将字符串转换为数组

   ```js
   [...'hello'] // ['h', 'e', 'l', 'l', 'o']
   ```

#### Promise

##### Promise 是什么

`Promise`是现在流行的 JS 异步解决方案，相较于传统的回调函数，`Promise`不会引起回调地狱问题。

##### Promises/A+ 规范

该规范规定了`Promise`的实现标准。

##### Promise 的基本用法

1. ###### 一个 Promise 对象只能有三种状态：

   - pending 状态
   - fulfilled 状态（resolve）
   - rejected 状态

2. ###### Promise 对象的状态装换

   一个 `Promise` 对象的状态只能由 pending 转换为 fulfilled 或 rejected，一旦状态转换完，就不会再改变，称为期约落定（settled）。一个 `Promise` 对象有可能一直处于 pending 状态。

3. ###### Promise 使用

   1. 创建 Promise 实例

      ​	`Promise` 构造函数接收一个函数作为参数，该函数可以有两个参数，通常我们命名为 `resolve` 和 `reject` 。它们由 JS 引擎传入，我们只需要定义形参。当我们调用 `resolve()` 或 `reject()` 时，会把期约的状态落定为 fulfilled 或 rejeccted。

      ​	`resolve()` 和 `reject()` 传入的第一个参数将会作为==期约的解决的值==或==拒绝的理由==，调用 `reject()` 会抛出一个异步错误，该错误无法被 try/catch 捕获，但可以通过拒绝程序捕获。

      <u>Tips</u>：可以设置一个定时器来定时拒绝期约 `reject()`，来避免由于异步原因卡在 pending 状态。由于期约状态只会改变一次，所以再次拒绝也会静默失败。

      ```js
      let promise = new Promise(function(resolve, reject){
          // 在这里发起异步操作，比如 ajax 请求
          // 这里的代码是一定会同步执行的
          if (/* 异步操作成功 */) {
              resolve(value);
          } else {
              reject(error);
          }
      })
      ```

      

   2. then 方法

      ​	ES `Promise`对象实现了 `thenable` 接口，通过 **Promise.prototype.then()**，每一个 Promise 实例都可以在期约落定后执行 then 方法来完成后续处理操作。

      ​	`then` 方法接收最多两个参数，分别是 `onResolved(value)` 和 `onReject(reason)`，通过传入的 `value` 参数和 `reason` 参数我们可以在这两个函数内分别进行成功处理和失败处理。由于期约只能落定一次，所以这两个函数只有一个能执行。

      ​	`then` 方法的返回值是一个新的 `Promise` 对象，这样我们就可以将 .then 进行==链式调用==。这个新的 `Promise` 对象会通过 ==Promise.resolve()== 来包装**成功处理程序**或**失败处理程序**的**返回值**（成功和失败都会返回一个成功的 ~，确实有点奇怪，但是仔细想想又没有错）。如果没有提供处理程序，将会 `Promise.resolve()` 来包装上一个期约解决后的值。如果处理程序中没有返回值，则会包装默认的 `undefined`。在处理程序中抛出异常则会返回一个 `rejected` 的期约。

      ```js
      // 第一个then通过返回了一个Promise.resolve(reason)，所以第二个then走的是成功调用
      let p = Promise.reject("oops!")
      p.then(value => {
        return value
      }, reason => {
        return reason
      }).then(value => {
        console.log('resolved!', value)
      }, reason => {
        console.log('rejected!', reason)
      })
      // resolved! oops!
      
      
      // 如果第一个then不写失败处理，那么第一个then返回了上一个Promise解决的值，也就是失败的'oops!'，所以第二个then方法走的是失败调用
      let p = Promise.reject("oops!")
      p.then(value => {
        return value
      }).then(value => {
        console.log('resolved!', value)
      }, reason => {
        console.log('rejected!', reason)
      })
      // rejected! oops!
      ```

   3. catch 方法和 finally 方法

      `Promise.prototype.catch()` 可以给期约添加失败处理程序。实质上是一个语法糖，相当于 `.then(null, onRejected)`。

      `Promise.prototype.finally()` 可以给期约添加 `onFinally` 处理程序，这个处理程序在期约成功和期约失败后都会执行。但是该方法没有办法知道期约的状态是成功还是拒绝。所以这个方法主要用来添加清理代码。

      ```js
      p.then()
      .then()
      .finally(() => {
      	// 在这里添加处理程序
      })
      ```

4. ###### 执行顺序

   `Promise` 中 `then` 的 onResolved/onRejected（说是 then 也一样），`catch`，`finally` 处理方法属于微任务，当期约落定时处理程序只是会进入微任务队列，而不是立即执行，具体执行时机需要分析 JS 事件循环机制。所以同步代码一定先异步处理代码先执行，即使在他后面。

#### class 语法糖

##### 	类定义

​	使用`class`关键字定义类时和函数定义类似，有类声明和类表达式两种方式，但是类定义不能提升（函数声明可以提升）。

```js
// 类定义
class Person{}

// 类表达式
const person = class Person{}
```

​	class 声明的类受块作用域限制，而传统 function 类没有

```js
{
	function FunctionDeclaration(){}	
  class ClassDeclaration {}
}
console.log(FunctionDeclaration) // FunctionDeclaration(){}
console.log(ClassDeclaration) // ReferenceError: ClassDeclaration is not defined
```

##### 	类的构成

###### 	构造函数

​		使用`constructor`函数创建构造函数，不写构造函数则默认将构造函数设置为空函数

​		在使用`new`运算符时执行以下操作

1. 在内存中创建一个新对象
2. 这个对象内部的`[[Prototype]]`属性（`__proto__`）设置为构造函数的`prototype`
3. 构造函数的`this`指向这个新对象
4. 执行构造函数（给新对象添加属性）
5. 如果构造函数返回非空对象，则返回该对象（不会被`instanceof`检测出和类有关联）；否则返回刚创建的对象

```js
class Person{
	constructor(){
		this.name = 'Tom'
  }
}
```

​		类构造函数和普通构造函数的区别：类构造函数若是不使用 new 会抛出错误，而普通构造函数会将属性添加在全局变量上

###### 	实例方法

​		在类块中定义的方法将作为原型方法为实例共享

​		==不能在类块中给类的原型添加成员数据==

```js
class Person {
  age: 18 // Uncaught SyntaxError: Unexpected token
  
  constructor(){
    this.name = 'Tom'
  }

  sayHi(){
    console.log('Hello! I am ' + this.name);
  }
}

let person = new Person()
person.sayHi() // Hello! I am Tom
```

###### 	get, set 函数

```js
class Person {
  constructor(name, age){
    this._name = name
    this._age = age
  }

  sayHi(){
    console.log('Hello! I am ' + this._name);
  }

  get age(){
    if(this._age){
      return this._age
    }
    return 0
  }

  set age(newAge){
    if(newAge >= 0){
      this._age = newAge
    }
    return
  }
}

let person = new Person('Tom', 18)
person.sayHi() // Hello! I am Tom
console.log(person.age) // 18
person.age = 20
console.log(person.age) // 20
```

###### 	静态成员

​		使用`static`声明，==在`static`中，`this`指向类自身==，静态方法非常适合作为实例工厂

```js
class Person{
  constructor(age){
    this._age = age
  }
  
  static feet = 2

	static countFeet(){
    console.log(this.feet) // 2
	}

	// 使用随机年龄创建并返回一个实例对象
	static create(){
    return new Person(Math.floor(Math.radom() * 100))
  }
}
```

##### 类的本质

​	ES 中没有类这个类型，类实际上是个特殊的函数。

```js
class Person{}
typeof Person // function
```

​	类有`prototype`属性，`prototype`也有`constructor`指向类自身

​	也可以使用`instanceof`来检测构造函数原型是否在实例的原型链上

```js
class Person{}
let p = new Person()
p instanceof Person // true
```

##### 类的继承

###### 概述

​	ES6 支持单继承，使用 `extends` 关键字，就可以继承任何拥有构造函数和原型的对象（包括 ES5 的构造函数类）

```js
class Vechile {}

class Bus extends Vechile {}
// let Bus = class extends Vechile{} // 也可以用于表达式

let bus = new Bus()
console.log(bus instanceof Bus); // true
console.log(bus instanceof Vechile); // true

// 继承ES5的类
function Person() {}

class Engineer extends Person {}

let engineer = new Engineer()
console.log(engineer instanceof Engineer); // true
console.log(engineer instanceof Person); // true
```

###### super	

在构造函数中调用 `super()` 可以调用父类的构造函数，但是==不能在 `super()` 调用前使用 `this`==

在子类的静态方法中，`super` 指代父类，可以通过 `super` 调用父类静态方法

注意：

1. `super` ==只能在子类的构造函数和静态方法中使用==
2. ==不能单独引用 super 关键字==，要么用它调用构造函数，要么用它调用静态方法
3. ==不能在 `super()` 调用前使用 `this`==
4. ==如果没有定义子类的构造函数，则会默认在子类的空构造函数中调用 `super()`==，并传入所有父类定义的参数（使子类的构造函数和父类的构造函数相同）
5. ==子类若是定义了构造函数，则要么调用 `super`，要么返回一个对象==

#### 迭代器和生成器

##### 迭代器

为了实现通用迭代，ES6 引入了迭代器模式。

实现了 Iterator 接口的对象称之为”可迭代对象“，这个对象必须有一个属性以 `Symbol.iterator` 作为键，以一个工厂函数为值，该函数返回一个新的迭代器（指针对象）。

迭代器的遍历过程如下：

1. 创建一个指针对象（通过工厂函数），指向当前数据结构的起始位置。
2. 不断调用 `next()` 方法，将指针指向数据结构的下一个成员。
3. 直到指针指向数据结构的结束位置（`done: true`）。

每次调用 `next()` 方法时，==返回一个包含 `value` 和 `done` 属性的对象==。其中 `value` 属性是当前成员的值，`done` 是一个布尔值，标志着遍历是否结束。

```js
let obj = {
  // 尝试使用 for...of 循环来遍历 obj 内部的数组
  arr: ['a', 'b', 'c', 'd'],
  // 迭代器工厂函数
  [Symbol.iterator](){
    let i = 0

    return {
      // 使用箭头函数确保 this 指向 obj，普通函数会指向当前返回的对象
      next: () => {
        if(i >= this.arr.length){
          // 遍历完成
          return { done: true }
        }
        return { value: this.arr[i++], done: false }
      }
    }
  }
}

for(let val of obj){
  console.log(val)
}

// a
// b
// c
// d
```

使用迭代器可以用来进行以下操作：

1. for...of 循环
2. 解构
3. 扩展运算符
4. Array.from() 方法，从一个类数组或可迭代对象创建一个新的，浅拷贝的数组实例
5. 创建集合和映射
6. Promise.all() 和 Promise.race() 接收一个由期约组成的可迭代对象
7. yield* 操作符，在生成器中使用

##### 生成器

ES6 新增的生成器是一种新的异步解决方案，拥有在一个函数块中暂停和恢复代码执行的能力。

###### 基本概念

生成器的形式是一个函数，函数名称前面加一个星号（*）表示他是一个生成器。只要是可以定义函数的地方都可以定义生成器。

```js
function* generatorFn(){
	yield 'hello'
  yield 'world'
  return 'ending'
}
let iterator = generatorFn()
```

以上代码定义了一个生成器，他拥有三个状态：`hello` , `world` 和 `return` 语句。

当 generator 函数调用后函数并不立即执行，而是返回一个迭代器对象，该对象指向函数内部状态，通过调用迭代器对象的 `next()` 方法来使指针移向下一个状态，也就是说，每次调用 `next()` 方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一条 yield 语句或 return 语句为止。换言之，generator 函数是分段执行的，yield 语句是暂停执行的标记，而 next 方法可以恢复执行。

```js
iterator.next()
// { value: 'hello', done: false }
iterator.next()
// { value: 'world', done: false }
iterator.next()
// { value: 'ending', done: true }
iterator.next()
// { value: undefined, done: true }
```

以上代码调用了 4 次 `next()` 方法。

第 1 次调用，`generatorFn` 函数开始执行，直到遇到第一条 `yield` 语句为止。`next()` 返回一个对象，它的 `value` 属性就是当前 `yield` 语句的值，`done` 属性值为 `false` 代表遍历还没有结束。

第 2 次调用，`generatorFn` 函数从上一次 `yield` 语句停下的地方开始执行，直到遇到下一条 `yield` 语句。`next()` 返回的对象的 `value` 属性是当前 `yield` 语句的值，`done` 属性值为 `false` 代表遍历还没有结束。

第 3 次调用，`generatorFn` 函数从上一次 `yield` 语句停下的地方开始执行，直到遇到 `return` 语句。`next()` 返回的对象的 `value` 属性是 `return` 后表达式的值，`done` 属性值为 `true` 代表遍历已经结束。

第 4 次调用，`generatorFn` 函数已经执行完毕。`next()` 返回的对象的 `value` 属性是 `undefined` ，`done` 属性值为 `true`。

###### yield 表达式

yield 语句是生成器函数中的暂停标志。迭代器对象的 `next` 方法的运行逻辑如下：

1. 遇到 `yield` 语句就暂停后面的操作，并将紧跟在 `yield` 后的表达式的值作为返回的对象的 `value` 属性值。
2. 再次调用时继续往下执行，直到遇到下一条 `yield` 语句或是 `return` 语句。
3. 遇到 `return` 语句就将 `return` 后面的表达式作为 `value` 值返回，若是没有 `return` 语句就将 `undefined` 作为 `value` 值。

###### 与 Iterator 接口的关系

由于任意一个对象的 `Symbol.iterator` 方法等于该对象的迭代器对象生成函数，调用该函数会返回该对象的一个迭代器对象，所以可以将生成器函数赋值给对象的 `Symbol.iterator` 属性，从而使得该函数实现 Iterator 接口。

###### next 方法的参数

### 模块化

#### CommonJS 模块化

CommonJS 模块化规范应用于 NodeJS 端，按照模块出现顺序==同步==加载模块，每个模块在加载一次之后==会被缓存==。模块导入后为==值的拷贝==。

##### 暴露模块

可以通过在 `module.exports` 上添加属性来暴露模块：

```js
let num = 1
function add(a, b){
	return a + b
}
module.exports.num = num
module.exports.add = add
```

也可以重写`module.exports`对象进行统一暴露：

```js
let num = 1
function add(a, b){
  return a + b
}
module.exports = {
  num,
  add
}
```

##### 导入模块

CommonJS 通过 `require` 语句来导入模块：

```js
let m = require('./module.js')
```

#### ES6 模块化

由于 CommonJS 不能用于浏览器端（同步加载模块会使浏览器“卡住”），ES6 推出了集 CommonJS 和 AMD 之大成者的 ES6 模块化规范，既可以应用在浏览器端，也可以应用在服务器端。

不同于 CommonJS，ES6 模块化异步递归加载依赖图，而且可以单独加载其中的某个接口。ES6 模块输出的是==值的只读引用（类似于 const）==。

##### 暴露模块

ES6 通过 `export` 语句暴露模块，该语句只能出现在模块顶级，不能嵌套在某个块中。

`export` 语句会被提升至顶部，所以和导出值的相对位置并不重要。

1. 命名暴露

   ```js
   // 命名行内暴露
   export const baz = 'baz'
   export const bar = 'bar', foo = 'foo'
   export function foo(){}
   export function* foo(){}
   export class Foo {}
   
   // 命名子句暴露
   export { foo }
   export { foo, bar }
   export {foo as myFoo, bar }
   ```

2. 默认暴露

   默认暴露语句在每个模块中只能有一个

   ```js
   export default 'foo'
   export default 123
   export default { foo: 'foo' }
   export { foo, bar as default }
   export default function(){}
   export default class {}
   ```

##### 导入模块

ES6 通过 `import` 语句导入模块，和 `export` 一样，该语句只能出现在模块顶级。

`import` 语句也会被提升至模块顶部，不过还是建议把 `import` 放在模块顶部。

```js
// 对于命名暴露，导入语句类似解构赋值，命名必须一样
import { foo, bar } from './fooBarModule.js'
import { foo as fooModule } from './fooBarModule.js' // 重命名导入模块
import { * } from './fooBarModule.js' // 使用 * 导入全部接口

// 对于默认暴露，可以省略大括号，也可以不知道确切的接口名
import foo from './fooModule.js'
```

如果不需要导出，只需要加载模块可以只通过路径加载：

```js
import './foo.js'
```

在浏览器中导入模块需要将 script 标签的 `type` 属性改为 `module` 来告诉浏览器这是一个模块而不是普通脚本：

```html
<script type="module">
  import { tag } from './html.js'
 
  const h1 = tag('h1', 'Hello Modules!')
  document.body.appendChild(h1)
</script>

<!-- 或作为外部脚本来引入 -->
<script type="module" src="./app.js"></script>
```

### 异步请求
#### 原生 xhr 对象
#### Fetch API

Fetch API 能执行 xhr 对象的所有任务，且更容易使用。fetch 使用 Promise，而不是回调函数，且支持数据流处理。

###### 基本用法

`fetch()` 方法暴露在全局作用域中，调用这个方法时，浏览器会向指定 URL 发送请求。`fetch()` 接受一个 URL 字符串作为参数，默认向该网址发出 GET 请求，返回一个 Promise 对象。

当请求成功时（只要服务器返回了响应），期约会解决为一个 `Response` 对象。这个对象是 API 的封装，调用其中的 API 来读取资源（稍后介绍该对象）。

当请求失败时，期约会被拒绝。可以通过 catch 或 then 的失败处理来进行处理。

```js
function getSomething() {
  fetch('https://api.uixsj.cn/hitokoto/get?type=hitokoto&code=json')
    .then(val => {
    return val.json()
  }, err => {
    console.log(err)
  })
    .then(data => {
    console.log("data: ", data)
  })
}
getSomething()
```

或者使用 await 语法来改写

```js
async function getSomething() {
  try {
    let result = await fetch('https://api.uixsj.cn/hitokoto/get?type=hitokoto&code=json')
    return await result.json()
  } catch (err) {
    console.log("Request Failed", err)
  }
}

getSomething()
  .then(val => {
  console.log(val)
})
```

###### 判断请求是否成功

`fetch()`发出请求以后，有一个很重要的注意点：只有网络错误，或者无法连接时，`fetch()`才会报错，其他情况都不会报错，而是认为请求成功。

这就是说，即使服务器返回的状态码是 4xx 或 5xx，`fetch()`也不会报错（即 Promise 不会变为 `rejected`状态）。

只有通过`Response.status`属性，得到 HTTP 回应的真实状态码，才能判断请求是否成功。

###### Response 对象

**Response 的同步属性**

Response 对象的读取都是异步的，但是它也有一些同步属性（只读），可以立即读取：

1. `Response.ok` 属性返回一个布尔值，表示请求是否成功，`true` 对应 HTTP 请求的状态码 200 到 299，`false` 对应其他的状态码。
2. `Response.status` 属性返回一个数字，表示 HTTP 回应的状态码（例如200，表示成功请求）。
3. `Response.statusText` 属性返回一个字符串，表示 HTTP 回应的状态信息（例如请求成功以后，服务器返回"OK"）。
4. `Response.url` 属性返回请求的 URL。如果 URL 存在跳转，该属性返回的是最终 URL。
5. `Response.type` 属性返回请求的类型。可能的值如下：
   - `basic`：普通请求，即同源请求。
   - `cors`：跨域请求。
   - `error`：网络错误，主要用于 Service Worker。
   - `opaque`：如果`fetch()`请求的`type`属性设为`no-cors`，就会返回这个值，详见请求部分。表示发出的是简单的跨域请求，类似`<form>`表单的那种跨域请求。
   - `opaqueredirect`：如果`fetch()`请求的`redirect`属性设为`manual`，就会返回这个值，详见请求部分。
6. `Response.redirected` 属性返回一个布尔值，表示请求是否发生过跳转。

Response 对象还有一个 headers 属性，指向一个 Headers 对象，对应 HTTP 回应的所有标头。

**读取 Response 内容**

1. `response.text()` 返回一个期约，解决为将缓冲区转存得到的 utf-8 格式字符串
2. `response.json()` 返回一个期约，解决为将缓冲区转存得到的 JOSN
3. `response.formData()` 返回一个期约，解决为将缓冲区转存得到的 FormData 实例，主要用在 Service Worker 里面，拦截用户提交的表单，修改某些数据以后，再提交给服务器。
4. `response.arrayBuffer()` 返回一个期约，解决为将缓冲区转存得到的 ArrayBuffer 实例，主要用于获取流媒体文件。
5. `response.blob()` 返回一个期约，解决为将缓冲区转存得到的 Blob 实例，用于获取二进制文件。

**Response.clone()**

Stream 对象只能读取一次，读取完就没了。这意味着，前面的五个读取方法，只能使用一个，否则会报错。

Response 对象提供 `Response.clone()` 方法，创建 `Response` 对象的副本，实现多次读取。

###### 自定义 fetch 请求

`fetch()` 的第一个参数是 URL，还可以接受第二个参数，作为==配置对象==，定制发出的 HTTP 请求。

```js
const response = fetch(url, {
  // 请求方法
  method: "GET",
  // 请求头
  headers: {
    "Content-Type": "text/plain;charset=UTF-8"
  },
  // 请求体
  body: undefined,
  // 用于设定 fetch() 请求的 referer 标头
  referrer: "about:client",
  // 用于设定 Referer 标头的规则
  referrerPolicy: "no-referrer-when-downgrade",
  // 请求模式，默认是 cors，允许跨域请求
  mode: "cors", 
  // 是否发送 cookie
  credentials: "same-origin",
  // 如何处理缓存
  cache: "default",
  // 指定 HTTP 跳转的处理方法。
  redirect: "follow",
  // 指定一个哈希值，用于检查 HTTP 回应传回的数据是否等于这个预先设定的哈希值。
  integrity: "",
  // 用于页面卸载时，告诉浏览器在后台保持连接，继续发送数据。
  keepalive: false,
  // 属性指定一个 AbortSignal 实例，用于取消 fetch() 请求
  signal: undefined
});
```

###### 取消 fetch 请求

`fetch()`请求发送以后，如果中途想要取消，需要使用`AbortController`对象。

```js
let controller = new AbortController();
let signal = controller.signal;

fetch(url, {
  signal: controller.signal
});

signal.addEventListener('abort',
  () => console.log('abort!')
);

controller.abort(); // 取消

console.log(signal.aborted); // true
```

上面示例中，首先新建 AbortController 实例，然后发送`fetch()`请求，配置对象的`signal`属性必须指定接收 AbortController 实例发送的信号`controller.signal`。

`controller.abort()`方法用于发出取消信号。这时会触发`abort`事件，这个事件可以监听，也可以通过`controller.signal.aborted`属性判断取消信号是否已经发出。

下面是一个1秒后自动取消请求的例子。

```js
let controller = new AbortController();
setTimeout(() => controller.abort(), 1000);

try {
  let response = await fetch('/long-operation', {
    signal: controller.signal
  });
} catch(err) {
  if (err.name == 'AbortError') {
    console.log('Aborted!');
  } else {
    throw err;
  }
}
```

### JSON

`JSON.stringify()` 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。

```js
console.log(JSON.stringify({ x: 5, y: 6 }));
// expected output: '{"x":5,"y":6}'

console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
// expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
// expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// expected output: '"2006-01-02T15:04:05.000Z"'
```

#### 语法

**JSON.stringify(value[, replacer [, space]])**

#### 参数

- `value`

  将要序列化成 一个 JSON 字符串的值。

- `replacer` 可选

  如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

- `space` 可选

  指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于 1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

#### 返回值

一个表示给定值的 JSON 字符串

#### 转换规则

笔者总结：

- 简单值（数字，字符串，布尔值，null）总是转换为和 toString 方法基本一样的字符串（JSON.stringify("abc") -> ""abc""）
- JSON不安全的值（undefined，function，symbol）
  - 单独转换返回 undefined
  - 在对象中会被忽略
  - 在数组中该项是 null（来确保单元位置不变）
- 对象含有循环引用则会报错
- 对象中含有toJSON方法则会根据该方法的返回值来转化（JSON.stringify( 对象中 toJSON 方法的返回值 )，所以 toJSON 应该返回一个 JSON 安全的任意类型的值 ）

MDN：

- 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
- 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
- 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
- `undefined`、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 `null`（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如`JSON.stringify(function(){})` or `JSON.stringify(undefined)`.
- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
- 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们。
- Date 日期调用了 toJSON() 将其转换为了 string 字符串（同Date.toISOString()），因此会被当做字符串处理。
- NaN 和 Infinity 格式的数值及 null 都会被当做 null。
- 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。

```js
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1,"false",false]'
JSON.stringify({ x: 5 });                  // '{"x":5}'

JSON.stringify({x: 5, y: 6});
// '{"x":5,"y":6}'

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({x: undefined, y: Object, z: Symbol("")});
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({[Symbol("foo")]: "foo"});
// '{}'

JSON.stringify({[Symbol.for("foo")]: "foo"}, [Symbol.for("foo")]);
// '{}'
```



## 四、浏览器

### **浏览器缓存**

#### 浏览器缓存机制

① 浏览器在发送请求之前，会根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。② 没有命中强缓存规则，浏览器会发送请求，根据请求头的`last-modified`和`etag`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。③ 如果前两步都没有命中，则直接从服务端获取资源。

<img src="C:\Users\LiuZhiwen\Desktop\前端学习知识点\assets\浏览器缓存机制.jpg" alt="浏览器缓存机制" style="zoom: 33%;" />

#### 强缓存

强缓存：==不会向服务器发送请求，直接从缓存中读取数据==

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

1. 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求
2. 存在缓存标识和缓存结果，但是已经失效，强制缓存失败，则使用协商缓存（暂不分析）
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

强制缓存的规则：当浏览器向服务器发送请求时，服务器会==将缓存规则放入 HTTP 响应报文头中==返回给浏览器，控制强制缓存的字段是`Cache-Control`和`Expires`，其中，`Cache-Control`比`Expires`优先级更高

1. Expires

   Expires指定了缓存过期时间，Expires = max-age + 请求时间，需要和Last-modified结合使用。在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

   > Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

   

2. Cache-Control

   在HTTP/1.1中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：

   - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
   - private：所有内容只有客户端可以缓存，`Cache-Control`的默认取值
   - no-cache：客户端缓存内容，但是是否使用缓存则需要经过**协商缓存**来验证决定
   - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
   - max-age=xxx ：缓存内容将在xxx秒后失效

   > 需要注意的是，`no-cache`这个名字有一点误导。设置了`no-cache`之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而`no-store`才表示不会被缓存，即不使用强制缓存，也不使用协商缓存



#### 协商缓存

协商缓存就是==强制缓存失效后==，浏览器==携带缓存标识==向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回 304 和 Not Modified，浏览器从缓存中读取资源
- 协商缓存失效，返回 200 和请求结果，浏览器将请求结果重新写入缓存

Last-Modified 和 If-Modified-Since：

1. 浏览器首先发送一个请求，让服务器在响应头中返回请求的资源上次更新时间，就是`last-modified`，浏览器会缓存下这个时间。
2. 然后浏览器再下次请求中，请求头中带上`if-modified-since`:`[保存的last-modified的值]`。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。

由于 last-modified 依赖的是保存的绝对时间，还是会出现误差的情况：

1. 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；
2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用 etag。

etag

`etag`是`http`协议提供的若干机制中的一种`Web`缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和`last-modified`一样. - 浏览器会先发送一个请求得到`etag`的值，然后再下一次请求在`request header`中带上`if-none-match`:`[保存的etag的值]`。 - 通过发送的`etag`的值和服务端重新生成的`etag`的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

> etag能够解决 last-modified 的一些缺点，但是 etag 每次服务端生成都需要进行读写操作，而 last-modified 只需要读取操作，从这方面来看，etag 的消耗是更大的。

二者对比 - 精确度上：`Etag`要优于`Last-Modified`。 - 优先级上：服务器校验优先考虑`Etag`。 - 性能上：`Etag`要逊于`Last-Modified`



#### 缓存存放的位置

浏览器的网络请求的 Size 会出现三种情况：`from memory cache(内存缓存)`、`from disk cache(磁盘缓存)`以及资源大小数值。

- from memory cache：不请求网络资源，资源在内存当中，读取快速，但是占用内存资源，且进程关闭时会释放内存
- from disk cache：不请求网络资源，资源在磁盘当中，需要进行io操作，速度慢
- 资源大小数值：从服务器下载最新资源

浏览器读取缓存的顺序为 memory –> disk。



#### 用户行为对浏览器缓存的影响

1. 打开网页，地址栏输入地址： 查找 `disk cache` 中是否有匹配。如有则使用；如没有则发送网络请求。
2. 普通刷新 (F5)：因为 TAB 并没有关闭，因此 `memory cache` 是可用的，会被优先使用(如果匹配的话)。其次才是 `disk cache`。
3. 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control:no-cache`(为了兼容，还带了 `Pragma:no-cache`),服务器直接返回 200 和最新内容。

### **WebStorage**

#### webstorage

web Storage 是 HTML 5 引入的一个重要的功能，它可以在客户端本地存储数据，类似 cookie，但其功能却比 cookie 强大的多。cookie 的大小只有 4Kb 左右（浏览器不同，大小也不同），而 web Storage 的大小有 5MB。其 API 提供的方法有以下几种：

```js
setItem (key, value) ——  保存数据，以键值对的方式储存信息。
getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
clear () ——  删除所有的数据
key (index) —— 获取某个索引的key
```

#### localStorage

==localStorage 的生命周期是永久性的==。假若使用 localStorage 存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage 有 length 属性，可以查看其有多少条记录的数据。使用方法如下：

```js
var storage = null;
if(window.localStorage){              //判断浏览器是否支持localStorage
  storage = window.localStorage;     
  storage.setItem("name", "Rick");    //调用setItem方法，存储数据
  alert(storage.getItem("name"));     //调用getItem方法，弹框显示 name 为 Rick
  storage.removeItem("name");     		//调用removeItem方法，移除数据
  alert(storage.getItem("name"));   	//调用getItem方法，弹框显示 name 为 null
}
```

#### sessionStorage

==sessionStorage 的生命周期是在浏览器关闭前==。也就是说，在==整个浏览器未关闭前==，其数据一直都是存在的。 sessionStorage 也有 length 属性，其基本的判断和使用方法和 localStorage 的使用是一致的。
需要注意的有以下几点：

- 页面刷新不会消除数据，(==只有当全部关闭 index.html 和从其内部打开的所有页面或者直接关闭浏览器，才可以消除 sessionStorage 中的数据==。)
- 只有在当前页面打开的链接，才可以访 sessionStorage 的数据
- 使用 window.open 打开页面和改变 localtion.href 方式都可以获取到 sessionStorage 内部的数据



### cookie，session，token
### 加载网页的全部过程
### preflight 请求

#### 什么是预检请求

由于浏览器拦截跨域请求的方法是：请求可以发送到服务器，但是返回的响应被浏览器拦截了，所以这种情况可能会对数据库进行修改，为了避免这种情况的发生，浏览器必须先使用`options`发起一次预检请求来询问服务器是否允许该跨域请求。通常`preflight`请求不需要用户自己去管理和干预，它的发出的响应都是由浏览器和服务器自动管理的。

#### 什么时候发送

只要==不满足以下任意一点==就会发送

1. 请求方法是`get`,`post`或`head`
2. 请求头只能包含`Accept` ,`Accept-Language` ,`Content-Language` ,`Content-Type`, `DPR`, `Downlink` ,`Save-Data`, `Viewport-Width` ,`Width`
3. Content-Type 只能包含以下三种类型 `text/plain` `multipart/form-data` `application/x-www-form-urlencoded`
4. `XMLHttpRequestUpload`对象没有注册任何事件监听器
5. 请求中不能使用`ReadableStream`对象

对于常规的开发来说，主要的限制在前三条。最常见的场景是==设置了自定义请求头==和==`Content-Type`类型不在支持的范围以内==。

#### 发送的 options 请求内容

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```
其中，关键字段是`Origin`，表示请求来自哪个源。除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#### 服务器的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的 HTTP 回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

如果服务器否定了"预检"请求，会返回一个正常的 HTTP 回应，但是==没有任何CORS相关的头信息字段==。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他 CORS 相关字段如下。

```http
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）Access-Control-Allow-Methods**

==该字段必需==，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，==返回的是所有支持的方法，而不单是浏览器请求的那个方法==。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，==不限于浏览器在"预检"中请求的字段==。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是 20 天（1728000秒），即允许缓存该条回应 1728000 秒（即 20 天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

```http
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin`字段是==每次回应都必定包含的==。

### SEO 优化
### 跨域问题

#### 什么是跨域问题？

#### 怎么解决跨域问题？

1. 跨域资源共享 CORS

   [阮一峰 跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

2. jsonp

3. websocket

## 五、Vue

### 数据绑定

#### 单向数据绑定

使用 `v-bind` 进行单向数据绑定，数据只能从 data 流向页面。

和插值表达式一样，引号内（插值表达式是大括号内）被解析为 JS 表达式，可以直接读取到 data 中的所有属性。

```vue
v-bind:href="toURL" // 这里会去 data 中找 toURL 这个变量，没有会报错
```

#### 双向数据绑定

使用 `v-model` 进行双向数据绑定，数据不仅能从 data 流向页面，还能从页面流向 data。

`v-model` 默认收集的是 `value` 属性，一般应用在表单元素上。

### 事件修饰符

Vue 中的事件修饰符：

- prevent：阻止浏览器默认行为（原生 js 为 `event.preventDefault()`）

  ```vue
  @click.prevent="showInfo"
  ```

- stop：阻止事件冒泡（原生 js 为 `event.stopPropagation()`）

- once：事件只触发一次

- self：只有 event.target 是当前操作的元素时才触发事件

- capture：使用事件的捕获模式

- passive：事件的默认行为立即执行，无需等待事件回调执行完

### 计算属性与监视

#### 计算属性

使用 method 也可以实现响应式的变化，因为 Vue 中的数据都是响应式的，更新时会通知所有依赖。

但是更好的方式是使用计算属性，计算属性可以对新值进行缓存，性能会更好，且方便调试。

每个计算属性为一个对象，对象中有 `get` 方法和 `set` 方法，其作用和 `Object.defineProperty()` 的 getter 和 setter 一样（底层也是它），`set`接收一个参数，为修改后的新值。

在==初次读取数据==，以及==依赖的数据变化时==， `get` 函数都会调用。

当计算属性被修改时，`set` 函数被调用。

```vue
<div id="app">
  <input type="text" v-model="a"> <br>
  <input type="text" v-model="b"> <br>
  <input type="text" v-model="ab">
</div>
<script src='./vue.js'></script>
<script>
  const vm = new Vue({
    el: '#app',
    data: {
      a: 'Hello',
      b: 'World!'
    },
    computed: {
      ab: {
        get() {
          return this.a + '-' + this.b
        },
        set(value) {
          this.a = value.split("-")[0]
          this.b = value.split("-")[1]
          console.log("ab is modefied!")
        }
      }
    }
  })
</script>
```

当不需要 `set` 函数时，可以简写计算属性为一个函数，该函数为 `get`。一般我们都使用这种形式。

```vue
<div id="app">
  <input type="text" v-model="a"> <br>
  <input type="text" v-model="b"> <br>
  <input type="text" v-model="ab">
</div>
<script src='./vue.js'></script>
<script>
  const vm = new Vue({
    el: '#app',
    data: {
      a: 'Hello',
      b: 'World!'
    },
    computed: {
      ab(){
        return this.a + '-' + this.b
      }
    }
  })
</script>
```



### 收集表单数据

在 Vue 中收集表单数据经常使用 `v-model` 指令进行数据的双向绑定，不同的表单类型有不同的收集细节：

- 若 `<input type="text"/>`，则 `v-model` 收集的是 `value` 属性，用户输入的也是 `value` 值。
- 若 `<input type="radio"/>`（单选框），则 `v-model` 收集的是 `value` 属性，且==需要给标签配置 `value` 值==。
- 若 `<input type="checkbox"/>`（多选框）
  - 没有配置 `input` 的 `value` 属性，那么收集到的就是 `checked` 属性（`true` 或 `false`，勾选未勾选）。
  - 配置了 `input` 的 `value` 属性，且 `v-model` 初始值为==非数组==，那么收集的也是 `checked` 属性。
  - 配置了 `input` 的 `value` 属性，且 `v-model` 初始值为==数组==，那么收集的就是 `value` 组成的数组。

`v-model` 的修饰符：

- `lazy`：失去焦点后再收集数据（适合多行输入）
- `number`：输入字符串转为有效数字
- `trim`：去除首尾空格

### 变化侦测

Vue 会监视 `data` 中所有数据（递归的监视，所有层次），对于对象和数组，Vue 的变化侦测并不一样

#### 对象的变化侦测

通过 `Object.defineProperty()` 设置属性的 setter 函数来收集依赖，在 getter 函数中触发依赖（通知变化）。

在新建 Vue 实例时就要传入所有数据，后添加进 `_data` 或是 `Vue 实例`的数据不会变为响应式数据，若是想要追加数据，可以用 `Vue.set()` 函数添加，也会变为响应式数据，但 ==`set` 函数的目标对象不能是 Vue 实例，或者 Vue 实例的根数据对象==。

```vue
// Vue.set( target, propertyName/index, value )

Vue.set(vm.student, "name", "张三")
// 或
vm.$set(vm.student, "name", "张三")
```

#### 数组的变化侦测

Vue 重写并覆盖了所有能修改数组的方法，来拦截对数组的操作，但是==直接通过下标修改数组还是无法被侦测到==。

- push
- pop
- shift
- unshift
- splice
- sort
- reverse

同样，通过 `set` 方法也可以修改数组元素（响应式）

### 生命周期钩子函数

