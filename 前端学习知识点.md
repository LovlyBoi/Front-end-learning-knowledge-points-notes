# 前端学习知识点

## 一、HTML

  ### 1. H5新标签
  ### 2. meta标签

## 二、CSS

### 1. 选择器
### 2. 盒模型
### 3. BFC，.clearfix清除塌陷
### 4. 浮动
### 5. 定位
### 6. em，rem，以及rem进行移动端布局
### 7. 过渡，动画，关键帧
### 8. 响应式布局
### 9. flex布局
### 10. grid布局
### 11. 圣杯布局
### 12. 双飞翼布局

## 三、JS

### 1. 基本类型
### 2. null和undefined
### 3. 原型链
### 4. 闭包
### 5. 执行上下文
### 6. this指向
### 7. 继承的实现
### 8. 深拷贝和浅拷贝
### 9. 事件循环机制
### 10. ES6
#### 1. let和const
#### 2. 数组新方法
#### 3. map，set
#### 4. rest参数，扩展运算符
#### 5. Promise
#### 6. class语法糖
### 11. 异步请求
#### 1. 原生xhr对象
#### 2. axios框架

## 四、浏览器

### 1. 浏览器缓存

1. #### 浏览器缓存机制

   ① 浏览器在发送请求之前，会根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。② 没有命中强缓存规则，浏览器会发送请求，根据请求头的`last-modified`和`etag`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。③ 如果前两步都没有命中，则直接从服务端获取资源。

   <img src="C:\Users\LiuZhiwen\Desktop\前端学习知识点\assets\浏览器缓存机制.jpg" alt="浏览器缓存机制" style="zoom: 33%;" />

2. #### 强缓存

   强缓存：==不会向服务器发送请求，直接从缓存中读取数据==

   强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

   1. 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求
   2. 存在缓存标识和缓存结果，但是已经失效，强制缓存失败，则使用协商缓存（暂不分析）
   3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

   强制缓存的规则：当浏览器向服务器发送请求时，服务器会==将缓存规则放入HTTP响应报文头中==返回给浏览器，控制强制缓存的字段是`Cache-Control`和`Expires`，其中，`Cache-Control`比`Expires`优先级更高

   1. Expires

      Expires指定了缓存过期时间，Expires = max-age + 请求时间，需要和Last-modified结合使用。在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

      > Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

      

   2. Cache-Control

      在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

      - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
      - private：所有内容只有客户端可以缓存，`Cache-Control`的默认取值
      - no-cache：客户端缓存内容，但是是否使用缓存则需要经过**协商缓存**来验证决定
      - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
      - max-age=xxx ：缓存内容将在xxx秒后失效

      > 需要注意的是，`no-cache`这个名字有一点误导。设置了`no-cache`之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而`no-store`才表示不会被缓存，即不使用强制缓存，也不使用协商缓存

   

3. #### 协商缓存

   协商缓存就是==强制缓存失效后==，浏览器==携带缓存标识==向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

   - 协商缓存生效，返回304和Not Modified，浏览器从缓存中读取资源
   - 协商缓存失效，返回200和请求结果，浏览器将请求结果重新写入缓存

   Last-Modified和If-Modified-Since：

   1. 浏览器首先发送一个请求，让服务器在响应头中返回请求的资源上次更新时间，就是`last-modified`，浏览器会缓存下这个时间。
   2. 然后浏览器再下次请求中，请求头中带上`if-modified-since`:`[保存的last-modified的值]`。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。

   由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：

   1. 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；
   2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。

   etag

   `etag`是`http`协议提供的若干机制中的一种`Web`缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和`last-modified`一样. - 浏览器会先发送一个请求得到`etag`的值，然后再下一次请求在`request header`中带上`if-none-match`:`[保存的etag的值]`。 - 通过发送的`etag`的值和服务端重新生成的`etag`的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

   > etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。

   二者对比 - 精确度上：`Etag`要优于`Last-Modified`。 - 优先级上：服务器校验优先考虑`Etag`。 - 性能上：`Etag`要逊于`Last-Modified`

   

4. #### 缓存存放的位置

   浏览器的网络请求的Size会出现三种情况：`from memory cache(内存缓存)`、`from disk cache(磁盘缓存)`以及资源大小数值。

   - from memory cache：不请求网络资源，资源在内存当中，读取快速，但是占用内存资源，且进程关闭时会释放内存
   - from disk cache：不请求网络资源，资源在磁盘当中，需要进行io操作，速度慢
   - 资源大小数值：从服务器下载最新资源

   浏览器读取缓存的顺序为memory –> disk。

   

5. #### 用户行为对浏览器缓存的影响

   1. 打开网页，地址栏输入地址： 查找 `disk cache` 中是否有匹配。如有则使用；如没有则发送网络请求。
   2. 普通刷新 (F5)：因为 TAB 并没有关闭，因此 `memory cache` 是可用的，会被优先使用(如果匹配的话)。其次才是 `disk cache`。
   3. 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control:no-cache`(为了兼容，还带了 `Pragma:no-cache`),服务器直接返回 200 和最新内容。

### 2. WebStorage

1. webstorage

   web Storage 是HTML 5引入的一个重要的功能，它可以在客户端本地存储数据，类似cookie，但其功能却比cookie强大的多。cookie的大小只有4Kb左右（浏览器不同，大小也不同），而web Storage的大小有5MB。其API提供的方法有以下几种：

   ```js
   setItem (key, value) ——  保存数据，以键值对的方式储存信息。
   getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
   removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
   clear () ——  删除所有的数据
   key (index) —— 获取某个索引的key
   ```

2. localStorage

   ==localStorage的生命周期是永久性的==。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：

   ```js
   var storage = null;
   if(window.localStorage){              //判断浏览器是否支持localStorage
     storage = window.localStorage;     
     storage.setItem("name", "Rick");    //调用setItem方法，存储数据
     alert(storage.getItem("name"));     //调用getItem方法，弹框显示 name 为 Rick
     storage.removeItem("name");     		//调用removeItem方法，移除数据
     alert(storage.getItem("name"));   	//调用getItem方法，弹框显示 name 为 null
   }
   ```

3. sessionStorage

   ==sessionStorage 的生命周期是在浏览器关闭前==。也就是说，在==整个浏览器未关闭前==，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。
   需要注意的有以下几点：

   - 页面刷新不会消除数据，(==只有当全部关闭index.html和从其内部打开的所有页面或者直接关闭浏览器，才可以消除sessionStorage中的数据==。)
   - 只有在当前页面打开的链接，才可以访sessionStorage的数据
   - 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据

   

### 3. cookie，session，token
### 4. 加载网页的全部过程
### 5. preflight请求
1. 由于浏览器拦截跨域请求的方法是：请求可以发送到服务器，但是返回的响应被浏览器拦截了，所以这种情况可能会对数据库进行修改，为了避免这种情况的发生，浏览器必须先使用`options`发起一次预检请求来询问服务器是否允许该跨域请求。通常`preflight`请求不需要用户自己去管理和干预，它的发出的响应都是由浏览器和服务器自动管理的。

2. 什么时候发送？只要==不满足以下任意一点==就会发送
   1. 请求方法是`get`,`post`或`head`
   2. 请求头只能包含`Accept` ,`Accept-Language` ,`Content-Language` ,`Content-Type`, `DPR`, `Downlink` ,`Save-Data`, `Viewport-Width` ,`Width`
   3. Content-Type只能包含以下三种类型 `text/plain` `multipart/form-data` `application/x-www-form-urlencoded`
   4. `XMLHttpRequestUpload`对象没有注册任何事件监听器
   5. 请求中不能使用`ReadableStream`对象

   对于常规的开发来说，主要的限制在前三条。最常见的场景是==设置了自定义请求头==和==`Content-Type`类型不在支持的范围以内==。

3. 发送的`options`请求内容？
   ```http
   OPTIONS /cors HTTP/1.1
   Origin: http://api.bob.com
   Access-Control-Request-Method: PUT
   Access-Control-Request-Headers: X-Custom-Header
   Host: api.alice.com
   Accept-Language: en-US
   Connection: keep-alive
   User-Agent: Mozilla/5.0...
   ```
   其中，关键字段是`Origin`，表示请求来自哪个源。除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

   **（1）Access-Control-Request-Method**

   该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

   **（2）Access-Control-Request-Headers**
   
   该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

4. 服务器的回应

   服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

   ```http
   HTTP/1.1 200 OK
   Date: Mon, 01 Dec 2008 01:15:39 GMT
   Server: Apache/2.0.61 (Unix)
   Access-Control-Allow-Origin: http://api.bob.com
   Access-Control-Allow-Methods: GET, POST, PUT
   Access-Control-Allow-Headers: X-Custom-Header
   Content-Type: text/html; charset=utf-8
   Content-Encoding: gzip
   Content-Length: 0
   Keep-Alive: timeout=2, max=100
   Connection: Keep-Alive
   Content-Type: text/plain
   ```

   上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

   如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是==没有任何CORS相关的头信息字段==。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

   ```
   XMLHttpRequest cannot load http://api.alice.com.
   Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
   ```

   服务器回应的其他CORS相关字段如下。

   ```http
   Access-Control-Allow-Methods: GET, POST, PUT
   Access-Control-Allow-Headers: X-Custom-Header
   Access-Control-Allow-Credentials: true
   Access-Control-Max-Age: 1728000
   ```

   **（1）Access-Control-Allow-Methods**

   ==该字段必需==，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，==返回的是所有支持的方法，而不单是浏览器请求的那个方法==。这是为了避免多次"预检"请求。

   **（2）Access-Control-Allow-Headers**

   如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，==不限于浏览器在"预检"中请求的字段==。

   **（3）Access-Control-Allow-Credentials**

   该字段与简单请求时的含义相同。

   **（4）Access-Control-Max-Age**

   该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

5. 浏览器的正常请求和回应

   一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

   ```http
   PUT /cors HTTP/1.1
   Origin: http://api.bob.com
   Host: api.alice.com
   X-Custom-Header: value
   Accept-Language: en-US
   Connection: keep-alive
   User-Agent: Mozilla/5.0...
   ```

   上面头信息的`Origin`字段是浏览器自动添加的。

   下面是服务器正常的回应。

   ```http
   Access-Control-Allow-Origin: http://api.bob.com
   Content-Type: text/html; charset=utf-8
   ```

   上面头信息中，`Access-Control-Allow-Origin`字段是==每次回应都必定包含的==。

### 6. SEO优化
### 7. 跨域问题

1. 什么是跨域问题？

2. 怎么解决跨域问题？

   1. 跨域资源共享CORS

      [阮一峰 跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

   2. jsonp

   3. websocket

## 五、Vue
### 1. 生命周期钩子函数 

