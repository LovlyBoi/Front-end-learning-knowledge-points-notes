# 前端学习知识点

## 一、HTML

  ### 1. H5新标签

1. header 表示头部
2. nav 表示导航
3. article 表示文章主体
4. aside 表示和页面主要内容有关，但不是页面的一部分，经常表示一个相关链接
5. footer 表示底部
6. audio 音频标签
7. video 视频标签

h5新标签提供了更好的语义化支持

  ### 2. meta标签

meta：文档级元数据元素，提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词

#### 属性

- name：

  - description 用于网站内容的描述，告诉搜索引擎网站的主要内容

    ```html
    <meta name="description" content="网站的描述">
    ```

  - keywords 告诉搜索引擎网页的关键字

    ```html
    <meta name="keywords" content="网站的关键字">
    ```

  - viewport 指定移动端的窗口

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ```

- http-equiv：

  - content-type 设定网页字符集

    ```html
    <meta charset="utf-8">
    ```

  - X-UA-Compatible 用于告知浏览器以何种版本来渲染页面

    ```html
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    ```

  - cache-control 指导浏览器如何缓存某个响应以及缓存多长时间

    ```html
    <meta http-equiv="cache-control" content="no-cache">
    ```

    - no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。
    - no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）
    - public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果
    - private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）
    - maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。

## 二、CSS

### 1. 选择器

#### 选择器列表

将多个选择器使用逗号组合起来形成选择器列表，当选择器列表中有选择器无效（语法错误）时，整个列表都会被忽略

#### 选择器种类

1. 类型选择器

   ```css
   h1{}
   ```

2. 类选择器

   ```css
   .box1{}   
   div.box1{}   /*div中所有box1类*/
   ```

3. ID选择器

   ```css
   #btn{}
   ```

4. 属性选择器

   ```css
   [title='mytitle']{}
   ```

5. 关系选择器

   1. 后代选择器

      ```css
      ul li{}
      ```

   2. 子代选择器

      ```css
      article > p{}
      ```

   3. 相邻兄弟选择器

      ```css
      h1 + p{}
      ```

   4. 通用兄弟选择器

      ```css
      h1 ~ p{}
      ```

6. 伪类选择器

   1. :checked

      ```css
      input:checked{}   /*选择所有被选中的input标签*/
      ```

   2. :default

      ```css
      input:default{}   /*选择所有默认的input*/
      ```

   3. :focus

      ```css
      input:focus{}   /*选择获得焦点的input*/
      ```

   4. :disabled

      ```css
      input:disabled{}   /*选择所有禁用的input*/
      ```

   5. :enabled

      ```css
      input:enabled{}   /*选择所有启用的input*/
      ```

   6. :first-child

      ```css
      p:first-child{}   /*选择每一组p标签中第一个p标签（第一个子代元素必须是p，否则不匹配）*/
      ```

   7. :first-of-type

      ```css
      p:first-of-type{}   /*选择一组p标签兄弟中的第一个p标签（不需要考虑父元素的第一个子代元素）*/
      ```

   8. :nth-child
   
7. 伪元素选择器

   1. ::before

      ```css
      div::before{
      	content: ">";   /*创建一个伪元素，作为该元素的第一个子元素，默认为行内元素*/
      }
      ```

   2. ::after

      ```css
      div::after{
        content: "<";   /*创建一个伪元素，作为已选中元素的最后一个子元素，默认是行内元素*/
      }
      ```

8. 通配选择器

   ```css
   *{
   	/*选择所有元素*/
   }
   ```


### 2. 选择器权重

不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。

一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：

1. **千位**： 如果声明在 [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style) 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。
2. **百位**： 选择器中包含ID选择器则该位得一分。
3. **十位**： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。
4. **个位**：选择器中包含元素、伪元素选择器则该位得一分。

> 通用选择器 (`*`)，组合符 (`+`, `>`, `~`, ' ')，和否定伪类 (`:not`) 不会影响优先级。
>
> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。

!important 能覆盖所有规则

### 3. 盒模型

#### 盒模型

组成一个块级盒模型需要：

- Content box：这个区域是用来显示内容，大小可以通过设置 [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height)。
- Padding box：包围在内容区域外部的空白区域； 大小通过 [`padding`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding) 相关属性设置。
- Border box：边框盒包裹内容和内边距。大小通过 [`border`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/border) 相关属性设置。
- Margin box：这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 [`margin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin) 相关属性设置。

当设置width和height时，设置的是content box，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。

元素的总宽度应该这样计算：

元素总宽度 = 宽度 + 左内边距 + 右内边距 + 左边框 + 右边框 + 左外边距 + 右外边距

元素的总高度应该这样计算：

元素总高度 = 高度 + 上内边距 + 下内边距 + 上边框 + 下边框 + 上外边距 + 下外边距

#### 外边距

外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。

##### 外边距折叠

如果有两个外边距相接的元素，这些外边距将==合并为一个外边距==，即最大的单个外边距的大小。

#### 内联盒子

对于内联盒子（内联元素），设置==宽度和高度会被忽略==，但==内边距，外边距和边框生效==，但它们不会改变其他内容与内联盒子的关系，因此==内边距和边框会与段落中的其他单词重叠==。解决方法：display: inline-block;

### 4. BFC，.clearfix清除塌陷

块级格式化上下文（Block Formatting Context, BFC），是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

#### 创建BFC

- 根元素（html）
- 浮动元素（元素的float不是none）
- 绝对定位元素（display: absolute或display: fixed）
- 行内块元素（display: inline-block）
- `display` 值为 `flow-root` 的元素
- 表格单元格（元素的 `display` 为 `table-cell`，HTML表格单元格默认为该值）
- 表格标题（元素的`display`为 `table-caption`，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的`display`为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）
- overflow不为visible的元素
- 弹性元素（flex的直接子元素）
- 网格元素（gird的直接子元素）

#### BFC的作用

- 父元素高度塌陷

  当子元素高度大于父元素，且子元素开启浮动后，由于子元素脱离了文档流，会导致父元素高度塌陷。

  ###### 解决方法

  - 改变父元素的 `overflow` 值，开启父元素的BFC，这时父元素会变成一个迷你布局，将包含浮动的子元素

  - 开启父元素的 `display: flow-root` ，它可以创建无副作用的 BFC。关于值 `flow-root`的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的`<html>`元素） 的东西时，就能发现这个名字的意义了——即==创建一个上下文，里面将进行 [flow layout](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout)==（也就是文档流布局）。

  - 添加一个新的空元素把父元素撑开（会占用仅有的两个伪元素）

    ```css
    .clearfix::before,   /*在前面加一个空的伪元素，解决父子外边距合并问题*/
    .clearfix::after{
        content:'';
        display:table;
        clear:both;   /*清除浮动影响，确保这个空元素能在浮动元素下面*/
    }
    ```

- 外边距合并

  两个相邻的盒子的外边距会合并在一起（①父元素有margin-top，子元素也有margin-top，且没有边框，这时两个margin-top重叠在一起，会产生合并,导致子元素的外边距无法在父元素内，父子元素会贴在一起；②两个兄弟元素之间的外边距重叠在一起,取最大值）

  ###### 解决方法

  - 给父元素加上边框（会改变盒子大小）
  - 开启父元素BFC
  - 使用clearfix类（在父元素前面加一个空的伪元素来隔开两个外边距）

### 5. 浮动
### 6. 定位
### 7. em，rem，以及rem进行移动端布局

#### em和rem

- em：font-size-of-the-element，em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小
- rem：font-size-of-the-root-element，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小

#### rem布局

由于100vw转换为设计图里的750px，假设有一个30px需要转换，可以得出30px / 750px = (x)vw / 100vw，即x = (100 / 750) * 30 ，然而每次需要换算时都进行`(100 / 设计图宽度) * 需要转换的px`实在是太麻烦了，所以使用rem来确定转换关系。

##### 思路

==设置根元素大小为一个固定数值 * (100vw / 设计图宽度)，这样我们在进行计算时只需要除以那个固定数值（通常是100）即可（单位是rem）==，这时1rem = 固定数值个设计图里的px（100px）

rem布局首先要操控根元素字体大小

```css
html{
    font-size: calc(100*100vw/750);
}
body{
  font-size:14px; /* 在这里把字体大小校正回来 */
}
```

这里是因为很多设计稿都是基于 iPhone6 来设计的，一般都是 750px（2 倍图，iPhone6 的设备宽度为 375px）所以除以  750 是为了在 iPhone6 设备下让 1rem 等于 100px。

```css
.menu li{
    display: table-cell;
    padding: .1rem .3rem;  /* 相当于10px 30px */
}
```



### 8. 过渡和动画

#### 1. 过渡

CSS 过渡 由简写属性`transition`定义是最好的方式，可以避免属性值列表长度不一，节省调试时间。

过渡的子属性有：

- `transition-property` 指定了哪些属性用于过渡，默认是all
- `transition-duration` 指定了过渡的时长，可以为多个属性指定不同的时长，单位是s或者ms
- `transition-timing-function` 指定了过渡的变化函数。默认是ease
  - ease 先加速再减速
  - linear 线性匀速变化
  - ease-in 加速
  - ease-out 减速
  - steps()指定分步执行过渡效果。接收两个参数，第一个是分成几步，第二个是end或start，决定了每一阶段的开始还是结束时执行，默认是end
  - cubic-bezier() 自定义运动曲线
- `transition-delay` 指定了执行的延迟时间，默认是0

简写属性

​	简写属性要求两个时间中，第一个是持续时间，第二个是延迟时间

```css
div {
    transition: <property> <duration> <timing-function> <delay>;
}
```

过渡时必须是从数值向数值过渡，而==不能向auto过渡==。

#### 2. 动画

在CSS中创建动画需要使用 `animation` 属性，该属性允许配置动画时间、时长以及其他动画细节，但该属性不能配置动画的实际表现，动画的实际表现是由 `@keyframes` 规则实现。

动画的子属性有：

- `animation-name` 指定由 `@keyframes` 描述的关键帧名称

- `animation-duration` 设置动画的时长

- `animation-delay` 设置延时，即从元素加载完成到动画开始执行的时间

- `animation-direction` 设置动画执的方向

  - normal：默认值，从头到尾，从头到尾...
  - reverse：从尾到头，从尾到头...
  - alternate：从头到尾，从尾到头，从头到尾...
  - alternate-reverse：从尾到头，从头到尾，从尾到头...

- `animation-iteration-count` 设置动画重复次数，可以指定infinite无限循环动画

- `animation-play-state` 动画默认在结束时跳回开始状态，要想保持结束时的状态，使用这个属性

  ```css
  /*没有鼠标没有悬停时，动画状态是暂停；一旦悬停，动画状态改为继续播放。*/
  div {
      animation: spin 1s linear infinite;
      animation-play-state: paused;
  }
  
  div:hover {
    animation-play-state: running;
  }
  ```

- `animation-timing-function` 指定了动画的运动曲线

- `animation-fill-mode` 指定动画的填充模式

  - none：默认值，结束后回到元素原来的状态。
  - forwards：结束后让动画停留在结束状态 （to的状态）。
  - backwards：结束后让动画回到第一帧的状态（from的状态）。
  - both: 根据animation-direction轮流应用forwards和backwards规则。

动画的简写属性

```css
/*以下两种写法是等价的*/
div:hover {
  animation: 2s 1s rainbow linear 3 forwards normal;
}

div:hover {
  animation-name: rainbow;
  animation-duration: 2s;
  animation-timing-function: linear;
  animation-delay: 1s;
  animation-fill-mode: forwards;
  animation-direction: normal;
  animation-iteration-count: 3;
}
```

使用@keyframes定义动画关键帧

> ​	`0%`表示动画的第一时刻，`100%`表示动画的最终时刻。因为这两个时间点十分重要，所以还有特殊的别名：`from`和`to`。这两个都是可选的，若`from/0%`或`to/100%`未指定，则浏览器使用计算值开始或结束动画。

```css
/*该例中<p>元素由浏览器窗口右边滑至左边*/
p {
  animation: 3s slidein;
}

@keyframes slidein {
  from {
    margin-left: 100%;
    width: 300%;
  }

  to {
    margin-left: 0%;
    width: 100%;
  }
}
```



### 9. 变形

变形是通过CSS来改变元素的形状或位置，变形==不会影响页面的布局==，使用transform来设置变形效果

使用  `transform-origin` 来设置变形原点，可选值：left，top...或X,Y值。默认为center

#### 平移

​	若使用百分比，百分比相对自己计算。（可以通过这一点来使元素居中）

- `translateX()` 沿着X轴平移

- `translateY()` 沿着Y轴平移

- `translateZ()` 沿着Z轴平移，数值越大，离人越近。但是默认情况下网页是不支持透视的（大小不变），想要看见效果必须==设置网页视距==

  ```css
  html{
  	/*设置网页的视距是800px（人眼距离网页的距离）*/
  	perspective: 800px;
  }
  ```

#### 旋转

​	需要设置视距来产生大小变化效果

- `rotateX()` 沿着X轴顺时针旋转，单位是deg（度数）或turn（几圈）
- `rotateY()` 沿着Y轴顺时针旋转
- `rotateZ()` 沿着Z轴顺时针旋转

#### 缩放

- `scale()` 对X和Y轴都进行缩放
- `scaleX()` 对X轴进行缩放
- `scaleY()` 对Y轴进行缩放
- `scaleZ()` 对Z轴进行缩放

### 10. flex布局

flex布局即为弹性布局，为盒模型开启`display: flex`后，该盒模型就会成为flex容器，他其中的子元素会成为弹性元素。

flex容器有两根轴，分别是默认的==水平主轴==（main axis）和与主轴垂直的==辅轴==（cross axis），弹性元素默认沿着主轴排列。

#### flex容器的属性

- flex-direction 修改主轴方向，可选 `row` , `row-reverse` , `column` , `column-reverse`，默认为 `row`
- flex-wrap 修改是否换行，可选 `nowrap` , `wrap` , `wrap-reverse`，默认为 `nowrap`
- flex-flow 上面两个属性的简写，可以同时设定两个属性，默认为 `row nowrap`
- justify-content 定义了元素在主轴上的排列方式，可选 `flex-start` , `flex-end` , `center` , `space-around` , `space-between`
- align-items 定义了元素在辅轴上的排列方式，可选 `flex-start` , `flex-end` , `center` , `baseline` , `stretch`
- align-content 定义了多条辅轴（有换行时生效），可选 `flex-start` , `flex-end` , `center` , `space-between` , `space-around` , `stretch`

#### 弹性元素的属性

- order 定义元素的排列顺序，默认都是0，数值越小越靠前，`.item{order: 1}`会让这个元素排在为0的元素后面
- flex-grow 定义了有空余空间时元素的放大比例，默认是0，即不放大。如果所有元素的`flex-grow`属性都为1，则它们将等分剩余空间（如果有的话）。如果一个元素的`flex-grow`属性为2，其他元素都为1，则前者占据的剩余空间将比其他元素多一倍。
- flex-shrink 定义了空间不够时元素如何收缩，默认为1，即默认都会等比例缩小。如果一个元素的`flex-shrink`属性为0，其他元素都为1，则空间不足时，前者不缩小。负值对该属性无效。
- align-self 允许元素设定自己的辅轴对齐方式，默认为 `auto`，即继承父元素的 `align-items` 属性。该属性可能取6个值，除了 `auto`，其他都与 `align-items` 属性完全一致。

### 11. grid布局

网格布局将网页分隔成一个个网格，可以组合任意不同的网格。

使用 `display: grid` 布局的元素称为“容器（container）”，其中的子元素称为“项目（item）”。

注意：项目只能是容器的顶层子元素，不包含项目的子元素。Grid 布局只对项目生效。

#### 行，列，单元格和网格线

容器里面的水平区域称为"行"（row），垂直区域称为"列"（column）。

行和列的交叉区域，称为"单元格"（cell）。

划分网格的线，称为"网格线"（grid line）。水平网格线划分出行，垂直网格线划分出列。

正常情况下，`n`行有`n + 1`根水平网格线，`m`列有`m + 1`根垂直网格线，比如三行就有四根水平网格线。

#### 容器属性

##### grid-template-columns 属性， grid-template-rows 属性

- `grid-template-columns` 定义了容器有多少列，以及每一列的宽度
- `grid-template-rows` 定义了容器有多少行，以及每一行的高度

##### 重复，auto-fill及fr

1. repeat

   ```css
   .container {
     display: grid;
     grid-template-columns: repeat(3, 33.33%);
     grid-template-rows: repeat(3, 33.33%);
   }
   ```

2. auto-fill

   有时，单元格的大小是固定的，但是容器的大小不确定。如果希望每一行（或每一列）容纳尽可能多的单元格，这时可以使用`auto-fill`关键字表示自动填充。

   ```css
   .container {
     display: grid;
     grid-template-columns: repeat(auto-fill, 100px);
   }
   ```

   上面代码表示每列宽度`100px`，然后自动填充，直到容器不能放置更多的列。

3. fr单位

   为了方便表示比例关系，网格布局提供了`fr`关键字（fraction 的缩写，意为"片段"）。如果两列的宽度分别为`1fr`和`2fr`，就表示后者是前者的两倍。

   `fr`可以与绝对长度的单位结合使用，这时会非常方便。

   ```css
   .container {
     display: grid;
     grid-template-columns: 150px 1fr 2fr;
   }
   ```

   上面代码表示，第一列的宽度为150像素，第二列的宽度是第三列的一半。

##### grid-row-gap 属性， grid-column-gap 属性， grid-gap 属性

`grid-row-gap`属性设置行与行的间隔（行间距），`grid-column-gap`属性设置列与列的间隔（列间距）。

```css
.container {
  grid-row-gap: 20px;
  grid-column-gap: 20px;
}
```

上面代码中，`grid-row-gap`用于设置行间距，`grid-column-gap`用于设置列间距。

`grid-gap`属性是`grid-column-gap`和`grid-row-gap`的合并简写形式，语法如下。

```css
grid-gap: <grid-row-gap> <grid-column-gap>;
```

因此，上面一段 CSS 代码等同于下面的代码。

```css
.container {
  grid-gap: 20px 20px;
}
```

如果`grid-gap`省略了第二个值，浏览器认为第二个值等于第一个值。

> 根据最新标准，上面三个属性名的`grid-`前缀已经删除，`grid-column-gap`和`grid-row-gap`写成`column-gap`和`row-gap`，`grid-gap`写成`gap`。

##### grid-template-areas 属性

网格布局允许指定"区域"（area），一个区域由单个或多个单元格组成。`grid-template-areas`属性用于定义区域。

```css
.container {
  display: grid;
  grid-template-columns: 100px 100px 100px;
  grid-template-rows: 100px 100px 100px;
  grid-template-areas: 'a b c'
                       'd e f'
                       'g h i';
}
```

上面代码先划分出9个单元格，然后将其定名为`a`到`i`的九个区域，分别对应这九个单元格。

多个单元格合并成一个区域的写法如下。

```css
grid-template-areas: 'a a a'
                     'b b b'
                     'c c c';
```

上面代码将9个单元格分成`a`、`b`、`c`三个区域。

下面是一个布局实例。

```css
grid-template-areas: "header header header"
                     "main main sidebar"
                     "footer footer footer";
```

上面代码中，顶部是页眉区域`header`，底部是页脚区域`footer`，中间部分则为`main`和`sidebar`。

如果某些区域不需要利用，则使用"点"（`.`）表示。

```css
grid-template-areas: 'a . c'
                     'd . f'
                     'g . i';
```

上面代码中，中间一列为点，表示没有用到该单元格，或者该单元格不属于任何区域。

##### grid-auto-flow 属性

划分网格以后，容器的子元素会按照顺序，自动放置在每一个网格。默认的放置顺序是"先行后列"，即先填满第一行，再开始放入第二行，即下图数字的顺序。

这个顺序由`grid-auto-flow`属性决定，默认值是`row`，即"先行后列"。也可以将它设成`column`，变成"先列后行"。

`grid-auto-flow`属性除了设置成`row`和`column`，还可以设成`row dense`和`column dense`。这两个值主要用于，某些项目指定位置以后，剩下的项目怎么自动放置。

##### justify-items 属性， align-items 属性， place-items 属性

`justify-items`属性设置单元格内容的水平位置（左中右），`align-items`属性设置单元格内容的垂直位置（上中下）。

```css
.container {
  justify-items: start | end | center | stretch;
  align-items: start | end | center | stretch;
}
```

这两个属性的写法完全相同，都可以取下面这些值。

> - start：对齐单元格的起始边缘。
> - end：对齐单元格的结束边缘。
> - center：单元格内部居中。
> - stretch：拉伸，占满单元格的整个宽度（默认值）。

```css
.container {
  justify-items: start;
}
```

`place-items`属性是`align-items`属性和`justify-items`属性的合并简写形式。

```css
place-items: <align-items> <justify-items>;
```

下面是一个例子。

```css
place-items: start end;
```

如果省略第二个值，则浏览器认为与第一个值相等。

##### justify-content 属性， align-content 属性， place-content 属性

`justify-content`属性是==整个内容区域==在容器里面的水平位置（左中右），`align-content`属性是==整个内容区域==的垂直位置（上中下）。

```css
.container {
  justify-content: start | end | center | stretch | space-around | space-between | space-evenly;
  align-content: start | end | center | stretch | space-around | space-between | space-evenly;  
}
```

`place-content`属性是`align-content`属性和`justify-content`属性的合并简写形式。

```css
place-content: <align-content> <justify-content>
```

下面是一个例子。

```css
place-content: space-around space-evenly;
```

如果省略第二个值，浏览器就会假定第二个值等于第一个值。

#### 项目属性

##### grid-column-start 属性， grid-column-end 属性， grid-row-start 属性， grid-row-end 属性

项目的位置是可以指定的，具体方法就是指定项目的四个边框，分别定位在哪根网格线。

- `grid-column-start`属性：左边框所在的垂直网格线
- `grid-column-end`属性：右边框所在的垂直网格线
- `grid-row-start`属性：上边框所在的水平网格线
- `grid-row-end`属性：下边框所在的水平网格线

这四个属性的值，除了指定为第几个网格线，还可以指定为网格线的名字。

这四个属性的值还可以使用`span`关键字，表示"跨越"，即左右边框（上下边框）之间跨越多少个网格。

使用这四个属性，如果产生了项目的重叠，则使用`z-index`属性指定项目的重叠顺序。

##### grid-column 属性， grid-row 属性

`grid-column`属性是`grid-column-start`和`grid-column-end`的合并简写形式，`grid-row`属性是`grid-row-start`属性和`grid-row-end`的合并简写形式。

```css
.item {
  grid-column: <start-line> / <end-line>;
  grid-row: <start-line> / <end-line>;
}
```

下面是一个例子。

```css
.item-1 {
  grid-column: 1 / 3;
  grid-row: 1 / 2;
}
/* 等同于 */
.item-1 {
  grid-column-start: 1;
  grid-column-end: 3;
  grid-row-start: 1;
  grid-row-end: 2;
}
```

这两个属性之中，也可以使用`span`关键字，表示跨越多少个网格。

##### grid-area 属性

`grid-area`属性指定项目放在哪一个区域。

```css
.item-1 {
  grid-area: e;
}
```

`grid-area`属性还可用作`grid-row-start`、`grid-column-start`、`grid-row-end`、`grid-column-end`的合并简写形式，直接指定项目的位置。

```css
.item {
  grid-area: <row-start> / <column-start> / <row-end> / <column-end>;
}
```

下面是一个[例子](https://jsbin.com/duyafez/edit?css,output)。

```css
.item-1 {
  grid-area: 1 / 1 / 3 / 3;
}
```

##### justify-self 属性， align-self 属性， place-self 属性

`justify-self`属性设置单元格内容的水平位置（左中右），跟`justify-items`属性的用法完全一致，但只作用于单个项目。

`align-self`属性设置单元格内容的垂直位置（上中下），跟`align-items`属性的用法完全一致，也是只作用于单个项目。

```css
.item {
  justify-self: start | end | center | stretch;
  align-self: start | end | center | stretch;
}
```

这两个属性都可以取下面四个值。

- start：对齐单元格的起始边缘。
- end：对齐单元格的结束边缘。
- center：单元格内部居中。
- stretch：拉伸，占满单元格的整个宽度（默认值）。

#### 媒体查询

使用媒体查询来修改grid布局十分简单，只需要修改对应的template-area

```css
@media (min-width: 500px) {
    .wrapper {
        grid-template-columns: repeat(9, 1fr);
        grid-template-areas:
          "hd hd hd hd   hd   hd   hd   hd   hd"
          "sd sd sd main main main main main main"
          "sd sd sd  ft  ft   ft   ft   ft   ft";
    }
}
@media (min-width: 700px) {
    .wrapper {
        grid-template-areas:
          "hd hd hd   hd   hd   hd   hd   hd hd"
          "sd sd main main main main main ft ft";
    }
}
```

### 12. 圣杯布局

### 13. 双飞翼布局

## 三、JS

### 1. 数据类型

JS中一共有6种简单数据类型和1种复杂数据类型

#### 简单数据类型

箭头后是typeof运算结果

- Number  -->  number
- String  -->  string
- Boolean  -->  boolean
- Undefined  -->  undefined
- Null -->  object(null表示空对象，所以不能用typeof判断null)
- Symbol  -->  symbol

#### 复杂数据类型

- Object  -->  object

### 2. null和undefined



### 3. 原型链
### 4. 执行上下文（重点哟）

在js中一共有三种执行上下文（Execution Context），分别是全局上下文，函数上下文和eval上下文（==对象是没有上下文的==），每个上下文都有一个变量对象，保存了这个上下文中定义的全部变量和函数。

使用var声明的变量会被自动添加到最近的上下文活动对象

#### 上下文栈

在执行每一个上下文时，会将它推入执行上下文栈，该栈的栈底是全局上下文，每个上下文会在它所有代码执行完毕后销毁出栈，（函数每次执行都会产生一个函数上下文）

#### 执行上下文的创建阶段（以函数上下文为例）

1. 生成变量对象

   1. **检索当前上下文中的参数**。该过程生成 arguments 对象，并建立以形参变量名为属性名，形参变量值为属性值的属性；

   2. **检索当前上下文中的函数声明**。该过程建立以函数名为属性名，函数所在内存地址引用为属性值的属性；

   3. **检索当前上下文中的变量声明**。该过程建立以变量名为属性名，undefined 为属性值的属性。

   4. ```js
      function fn(){
        console.log('fn!!');
      }
      
      fn(); // fn!!
      
      var fn = 2;
      
      fn(); // TypeError: fn is not a function（fn = 2将函数覆盖了）
      ```

2. 建立作用域链

   每个函数保存了一个[[scope]]内部属性，它保存了函数上一层上下文到全局上下文的所有变量对象，==该属性在声明时已经确定==。

   当函数被调用时，会创建自己的执行上下文和变量对象，将该变量对象加入到[[scope]]的最前端，构成完整的作用域链。

   代码执行时的标识符解析会沿着该链向上查找，直到全局上下文

3. 确定this指向

   ==this指向是在这时才确定的！只有在函数被调用，创建其上下文时才能确定this==。

   分析this指向

   1. 全局上下文中this指向全局对象（window）
   2. 函数如果由对象调用，则指向该对象
   3. 如果该函数被独立调用，那么其内部的 this 指向 window（严格模式下指向 undefined）
   4. 构造函数中的this指向新创建的对象

   拓展：箭头函数的this指向

   箭头函数没有自己的this，它会在创建时获取该上下文中的this（==在声明时就确定了==）

   ```js
   var name = 'window'; 
   
   var A = {
      name: 'A',
      sayHello: () => {
         console.log(this.name)
      }
   }
   
   A.sayHello(); // 输出window，获取了上一层的全局上下文（对象没有上下文）
   ```

#### 执行上下文的执行阶段

这时变量对象变为活动对象，执行其中的代码，原先声明的对象会在这里赋值。

#### 执行上下文的销毁阶段

上下文出栈，变量对象等待被垃圾回收。	

### 5. 闭包（closure）

初学者的最大痛点——闭包

##### 闭包是什么

在JS中，函数内部可以访问上层的作用域，但是上层的作用域（函数外部）无法访问内层的作用域。有些时候，我们想要在外部来访问函数内部的变量（或是将某些私有变量藏进函数执行上下文中），这时，我们可以在函数内部返回一个函数，通过这个里层函数来访问外层函数。

##### 怎么创建一个闭包

```js
// 在这里我们引用一个经典的例子，创建一个外部无法随意修改值的计数器
// 这里是全局上下文
function createCounter(){  // 外层函数，外层函数上下文
  let cnt = 0
  return function(){
		return ++cnt;  // 里层函数，里层函数上下文
  }
}

let counter = createCounter() // counter是里层函数
console.log(counter());  // 1
console.log(counter());  // 2
console.log(counter());  // 3
console.log(counter());  // 4
```

##### 原理（最好先看看我写的执行上下文相关的内容）

先介绍一下变量对象：==变量对象是与执行上下文相关的数据作用域，用于存储执行上下文中的变量和函数声明==。

我们为了不让外界随意修改cnt的值，创建了一个闭包，将想要藏起来的变量放进了外层函数上下文中（外层函数上下文的变量对象）。当外层函数执行完后，该上下文会被弹出上下文栈，其变量对象理应会因为没有被外界引用而被垃圾回收（gc），相信你也注意到了，只要我们==保存下来这个对变量对象的引用==，不就能避免这个变量对象被回收，继而保存下来cnt了吗？

但是变量对象怎么找到并保存呢，这里我们使用了一点小技巧，里层函数的作用域链头部（[[scope]]的头部）不就正是上一层上下文的变量对象吗？所以==只要外层函数内定义了其他函数==，这个外层函数的变量对象就不会被垃圾回收（从道理上来讲，里层函数还可能会用到他呢）。只要我们能拿到外层函数里的一个函数，那么我们就能操作外层函数的变量对象。

再回头看这个例子，第10行执行了外层函数，创建了一个包含cnt = 0的变量对象，又定义并返回了里层函数给counter变量，以此保存下来了外层变量对象。当里层函数再执行时（`counter()`），自然是先去作用域链上找自身的变量对象有没有cnt，发现没有后再往上找到我们一直苦心想要保存下来的外层变量对象，发现正好有cnt，即执行++cnt，使cnt = 1。

##### 例子与分析

在阮一峰老师的笔记那里找了两个例子

一：

```js
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    return function(){
      return this.name;
    };
  }
};

alert(object.getNameFunc()());
```

二：

```js
var name = "The Window";

var object = {
  name : "My Object",

  getNameFunc : function(){
    var that = this;
    return function(){
      return that.name;
    };
  }
};

alert(object.getNameFunc()());
```

分析：

一：

先说结论："The Window"。这里外层函数（`getNameFunc`）是对象的属性，所以上下文栈应该是：里层函数->外层函数->全局（对象没有上下文）。`object.getNameFunc()()` 可以分解为`object.getNameFunc()` 和 `()`，即先执行外层函数，得到里层函数，再执行里层函数。当执行外层函数时，返回了里层函数，所以该代码可以理解为`里层函数()`，这里的里层函数不是object调用的，而是独立调用，所以this指向全局，即输出"The Window"。

二：

二和一的区别是外层函数声明了that变量来保存外层函数的this，再来分析`object.getNameFunc()()` ，执行外层函数时（`object.getNameFunc()`），由于是object调用，this指向object（这里是执行时才能分析出来的哦，定义时是不知道this指向的），所以that指向的也是object，保存在变量对象中，里层函数执行时，先找自身没有that，随后找外层函数变量对象，发现有that，指向了object，于是 `that.name` 就是 `object.name` 了。

##### 感想

为什么大家一直觉得闭包很难呢，我觉得是因为对于闭包，不仅仅需要理解一个两个知识点，而是需要了解执行上下文，this指向，垃圾回收，作用域链等知识，才能理解闭包的原理。所以我强烈建议把这些知识点都看过后，再来看看闭包。

### 6. this指向

看执行上下文，里面有写。

### 7. 继承的实现
### 8. 深拷贝和浅拷贝
### 9. 事件循环机制

### 10. ES6

#### 1. let和const
#### 2. 数组新方法
#### 3. map，set
#### 4. rest参数，扩展运算符
#### 5. Promise

##### Promise 是什么

Promise是现在流行的 JS 异步解决方案，相较于传统的回调函数，Promise不会引起回调地狱问题。

##### Promises/A+ 规范

该规范规定了Promise的实现标准。

##### Promise 的基本用法

1. ###### 一个 Promise 对象只能有三种状态：

   - pending 状态
   - fulfilled 状态（resolve）
   - rejected 状态

2. ###### Promise 对象的状态装换

   一个 Promise 对象的状态只能由 pending 转换为 fulfilled 或 rejected，一旦状态转换完，就不会再改变，称为期约落定（settled）。一个 Promise 对象有可能一直处于 pending 状态。

3. ###### Promise 使用

   1. 创建 Promise 实例

      ​	Promise 构造函数接收一个函数作为参数，该函数可以有两个参数，通常我们命名为 `resolve` 和 `reject` 。它们由 JS 引擎传入，我们只需要定义形参。当我们调用 `resolve()` 或 `reject()` 时，会把期约的状态落定为 fulfilled 或 rejeccted。

      ​	`resolve()` 和 `reject()` 传入的第一个参数将会作为==期约的解决的值==或==拒绝的理由==，调用 `reject()` 会抛出一个异步错误，该错误无法被 try/catch 捕获，但可以通过拒绝程序捕获。

      <u>Tips</u>：可以设置一个定时器来定时拒绝期约 `reject()`，来避免由于异步原因卡在 pending 状态。由于期约状态只会改变一次，所以再次拒绝也会静默失败。

      ```js
      let promise = new Promise(function(resolve, reject){
          // 在这里发起异步操作，比如 ajax 请求
          // 这里的代码是一定会同步执行的
          if (/* 异步操作成功 */) {
              resolve(value);
          } else {
              reject(error);
          }
      })
      ```

      

   2. then 方法

      ​	ES Promise对象实现了 thenable 接口，通过 **Promise.prototype.then()**，每一个 Promise 实例都可以在期约落定后执行 then 方法来完成后续处理操作。

      ​	then 方法接收最多两个参数，分别是 `onResolved(value)` 和 `onReject(reason)`，通过传入的 `value` 参数和 `reason` 参数我们可以在这两个函数内分别进行成功处理和失败处理。由于期约只能落定一次，所以这两个函数只有一个能执行。

      ​	then 方法的返回值是一个新的 Promise 对象，这样我们就可以将 .then 进行==链式调用==。这个新的 Promise 对象会通过 ==Promise.resolve()== 来包装**成功处理程序**或**失败处理程序**的**返回值**（成功和失败都会返回一个成功的 Promise，确实有点奇怪，但是仔细想想又没有错）。如果没有提供处理程序，将会 Promise.resolve() 来包装上一个期约解决后的值。如果处理程序中没有返回值，则会包装默认的 `undefined`。在处理程序中抛出异常则会返回一个 rejected 的期约。

      ```js
      // 第一个then通过返回了一个Promise.resolve(reason)，所以第二个then走的是成功调用
      let p = Promise.reject("oops!")
      p.then(value => {
        return value
      }, reason => {
        return reason
      }).then(value => {
        console.log('resolved!', value)
      }, reason => {
        console.log('rejected!', reason)
      })
      // resolved! oops!
      
      
      // 如果第一个then不写失败处理，那么第一个then返回了上一个Promise解决的值，也就是失败的'oops!'，所以第二个then方法走的是失败调用
      let p = Promise.reject("oops!")
      p.then(value => {
        return value
      }).then(value => {
        console.log('resolved!', value)
      }, reason => {
        console.log('rejected!', reason)
      })
      // rejected! oops!
      ```

   3. catch 方法和 finally 方法

      Promise.prototype.catch() 可以给期约添加失败处理程序。实质上是一个语法糖，相当于 `.then(null, onRejected)`。

      Promise.prototype.finally() 可以给期约添加 onFinally 处理程序，这个处理程序在期约成功和期约失败后都会执行。但是该方法没有办法知道期约的状态是成功还是拒绝。所以这个方法主要用来添加清理代码。

      ```js
      p.then()
      .then()
      .finally(() => {
      	// 在这里添加处理程序
      })
      ```

4. ###### 执行顺序

   Promise 中 then 的 onResolved/onRejected（说是 then 也一样），catch，finally 处理方法属于微任务，当期约落定时处理程序只是会进入微任务队列，而不是立即执行，具体执行时机需要分析 JS 事件循环机制。所以同步代码一定先异步处理代码先执行，即使在他后面。

#### 6. class语法糖

##### 	1. 类定义

​	使用class关键字定义类时和函数定义类似，有类声明和类表达式两种方式，但是类定义不能提升（函数声明可以提升）。

```js
// 类定义
class Person{}

// 类表达式
const person = class Person{}
```

​	class声明的类受块作用域限制，而传统function类没有

```js
{
	function FunctionDeclaration(){}	
  class ClassDeclaration {}
}
console.log(FunctionDeclaration) // FunctionDeclaration(){}
console.log(ClassDeclaration) // ReferenceError: ClassDeclaration is not defined
```

##### 	2. 类的构成

###### 	构造函数

​		使用constructor函数创建构造函数，不写构造函数则默认将构造函数设置为空函数

​		在使用new运算符时执行以下操作

1. 在内存中创建一个新对象
2. 这个对象内部的[[Prototype]]属性（`__proto__`）设置为构造函数的prototype
3. 构造函数的this指向这个新对象
4. 执行构造函数（给新对象添加属性）
5. 如果构造函数返回非空对象，则返回该对象（不会被instanceof检测出和类有关联）；否则返回刚创建的对象

```js
class Person{
	constructor(){
		this.name = 'Tom'
  }
}
```

​		类构造函数和普通构造函数的区别：类构造函数若是不使用new会抛出错误，而普通构造函数会将属性添加在全局变量上

###### 	实例方法

​		在类块中定义的方法将作为原型方法为实例共享

​		==不能在类块中给类的原型添加成员数据==

```js
class Person {
  age: 18 // Uncaught SyntaxError: Unexpected token
  
  constructor(){
    this.name = 'Tom'
  }

  sayHi(){
    console.log('Hello! I am ' + this.name);
  }
}

let person = new Person()
person.sayHi() // Hello! I am Tom
```

###### 	get, set函数

```js
class Person {
  constructor(name, age){
    this._name = name
    this._age = age
  }

  sayHi(){
    console.log('Hello! I am ' + this._name);
  }

  get age(){
    if(this._age){
      return this._age
    }
    return 0
  }

  set age(newAge){
    if(newAge >= 0){
      this._age = newAge
    }
    return
  }
}

let person = new Person('Tom', 18)
person.sayHi() // Hello! I am Tom
console.log(person.age) // 18
person.age = 20
console.log(person.age) // 20
```

###### 	静态成员

​		使用static声明，==在static中，this指向类自身==，静态方法非常适合作为实例工厂

```js
class Person{
  constructor(age){
    this._age = age
  }
  
  static feet = 2

	static countFeet(){
    console.log(this.feet) // 2
	}

	// 使用随机年龄创建并返回一个实例对象
	static create(){
    return new Person(Math.floor(Math.radom() * 100))
  }
}
```

##### 3. 类的本质

​	ES中没有类这个类型，类实际上是个特殊的函数。

```js
class Person{}
typeof Person // function
```

​	类有prototype属性，prototype也有constructor指向类自身

​	也可以使用instanceof来检测构造函数原型是否在实例的原型链上

```js
class Person{}
let p = new Person()
p instanceof Person // true
```

##### 4.类的继承

###### 概述

​	ES6支持单继承，使用extends关键字，就可以继承任何拥有构造函数和原型的对象（包括ES5的构造函数类）

```js
class Vechile {}

class Bus extends Vechile {}
// let Bus = class extends Vechile{} // 也可以用于表达式

let bus = new Bus()
console.log(bus instanceof Bus); // true
console.log(bus instanceof Vechile); // true

// 继承ES5的类
function Person() {}

class Engineer extends Person {}

let engineer = new Engineer()
console.log(engineer instanceof Engineer); // true
console.log(engineer instanceof Person); // true
```

###### super	

在构造函数中调用super()可以调用父类的构造函数，但是==不能在super()调用前使用this==

在子类的静态方法中，super指代父类，可以通过super调用父类静态方法

注意：

1. super==只能在子类的构造函数和静态方法中使用==
2. ==不能单独引用super关键字==，要么用它调用构造函数，要么用它调用静态方法
3. ==不能在super()调用前使用this==
4. ==如果没有定义子类的构造函数，则会默认在子类的空构造函数中调用super()==，并传入所有父类定义的参数（使子类的构造函数和父类的构造函数相同）
5. ==子类若是定义了构造函数，则要么调用super，要么返回一个对象==

### 11. 异步请求
#### 1. 原生xhr对象
#### 2. axios框架

### 12. JSON

`JSON.stringify()` 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。

```js
console.log(JSON.stringify({ x: 5, y: 6 }));
// expected output: '{"x":5,"y":6}'

console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
// expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
// expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// expected output: '"2006-01-02T15:04:05.000Z"'
```

#### 语法

**JSON.stringify(value[, replacer [, space]])**

#### 参数

- `value`

  将要序列化成 一个 JSON 字符串的值。

- `replacer` 可选

  如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

- `space` 可选

  指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

#### 返回值

一个表示给定值的JSON字符串

#### 转换规则

笔者总结：

- 简单值（数字，字符串，布尔值，null）总是转换为和toString方法基本一样的字符串（JSON.stringify("abc") => ""abc""）
- JSON不安全的值（undefined，function，symbol）
  - 单独转换返回undefined
  - 在对象中会被忽略
  - 在数组中该项是null（来确保单元位置不变）
- 对象含有循环引用则会报错
- 对象中含有toJSON方法则会根据该方法的返回值来转化（JSON.stringify( 对象中toJSON方法的返回值 )，所以toJSON应该返回一个JSON安全的任意类型的值 ）

MDN：

- 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
- 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
- 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
- `undefined`、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 `null`（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如`JSON.stringify(function(){})` or `JSON.stringify(undefined)`.
- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
- 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们。
- Date 日期调用了 toJSON() 将其转换为了 string 字符串（同Date.toISOString()），因此会被当做字符串处理。
- NaN 和 Infinity 格式的数值及 null 都会被当做 null。
- 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。

```js
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1,"false",false]'
JSON.stringify({ x: 5 });                  // '{"x":5}'

JSON.stringify({x: 5, y: 6});
// '{"x":5,"y":6}'

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({x: undefined, y: Object, z: Symbol("")});
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({[Symbol("foo")]: "foo"});
// '{}'

JSON.stringify({[Symbol.for("foo")]: "foo"}, [Symbol.for("foo")]);
// '{}'
```



## 四、浏览器

### 1. **浏览器缓存**

#### 浏览器缓存机制

① 浏览器在发送请求之前，会根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。② 没有命中强缓存规则，浏览器会发送请求，根据请求头的`last-modified`和`etag`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。③ 如果前两步都没有命中，则直接从服务端获取资源。

<img src="C:\Users\LiuZhiwen\Desktop\前端学习知识点\assets\浏览器缓存机制.jpg" alt="浏览器缓存机制" style="zoom: 33%;" />

#### 强缓存

强缓存：==不会向服务器发送请求，直接从缓存中读取数据==

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

1. 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求
2. 存在缓存标识和缓存结果，但是已经失效，强制缓存失败，则使用协商缓存（暂不分析）
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

强制缓存的规则：当浏览器向服务器发送请求时，服务器会==将缓存规则放入HTTP响应报文头中==返回给浏览器，控制强制缓存的字段是`Cache-Control`和`Expires`，其中，`Cache-Control`比`Expires`优先级更高

1. Expires

   Expires指定了缓存过期时间，Expires = max-age + 请求时间，需要和Last-modified结合使用。在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

   > Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

   

2. Cache-Control

   在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

   - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
   - private：所有内容只有客户端可以缓存，`Cache-Control`的默认取值
   - no-cache：客户端缓存内容，但是是否使用缓存则需要经过**协商缓存**来验证决定
   - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
   - max-age=xxx ：缓存内容将在xxx秒后失效

   > 需要注意的是，`no-cache`这个名字有一点误导。设置了`no-cache`之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而`no-store`才表示不会被缓存，即不使用强制缓存，也不使用协商缓存



#### 协商缓存

协商缓存就是==强制缓存失效后==，浏览器==携带缓存标识==向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回304和Not Modified，浏览器从缓存中读取资源
- 协商缓存失效，返回200和请求结果，浏览器将请求结果重新写入缓存

Last-Modified和If-Modified-Since：

1. 浏览器首先发送一个请求，让服务器在响应头中返回请求的资源上次更新时间，就是`last-modified`，浏览器会缓存下这个时间。
2. 然后浏览器再下次请求中，请求头中带上`if-modified-since`:`[保存的last-modified的值]`。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。

由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：

1. 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；
2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。

etag

`etag`是`http`协议提供的若干机制中的一种`Web`缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和`last-modified`一样. - 浏览器会先发送一个请求得到`etag`的值，然后再下一次请求在`request header`中带上`if-none-match`:`[保存的etag的值]`。 - 通过发送的`etag`的值和服务端重新生成的`etag`的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

> etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。

二者对比 - 精确度上：`Etag`要优于`Last-Modified`。 - 优先级上：服务器校验优先考虑`Etag`。 - 性能上：`Etag`要逊于`Last-Modified`



#### 缓存存放的位置

浏览器的网络请求的Size会出现三种情况：`from memory cache(内存缓存)`、`from disk cache(磁盘缓存)`以及资源大小数值。

- from memory cache：不请求网络资源，资源在内存当中，读取快速，但是占用内存资源，且进程关闭时会释放内存
- from disk cache：不请求网络资源，资源在磁盘当中，需要进行io操作，速度慢
- 资源大小数值：从服务器下载最新资源

浏览器读取缓存的顺序为memory –> disk。



#### 用户行为对浏览器缓存的影响

1. 打开网页，地址栏输入地址： 查找 `disk cache` 中是否有匹配。如有则使用；如没有则发送网络请求。
2. 普通刷新 (F5)：因为 TAB 并没有关闭，因此 `memory cache` 是可用的，会被优先使用(如果匹配的话)。其次才是 `disk cache`。
3. 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control:no-cache`(为了兼容，还带了 `Pragma:no-cache`),服务器直接返回 200 和最新内容。

### 2. **WebStorage**

#### webstorage

web Storage 是HTML 5引入的一个重要的功能，它可以在客户端本地存储数据，类似cookie，但其功能却比cookie强大的多。cookie的大小只有4Kb左右（浏览器不同，大小也不同），而web Storage的大小有5MB。其API提供的方法有以下几种：

```js
setItem (key, value) ——  保存数据，以键值对的方式储存信息。
getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
clear () ——  删除所有的数据
key (index) —— 获取某个索引的key
```

#### localStorage

==localStorage的生命周期是永久性的==。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：

```js
var storage = null;
if(window.localStorage){              //判断浏览器是否支持localStorage
  storage = window.localStorage;     
  storage.setItem("name", "Rick");    //调用setItem方法，存储数据
  alert(storage.getItem("name"));     //调用getItem方法，弹框显示 name 为 Rick
  storage.removeItem("name");     		//调用removeItem方法，移除数据
  alert(storage.getItem("name"));   	//调用getItem方法，弹框显示 name 为 null
}
```

#### sessionStorage

==sessionStorage 的生命周期是在浏览器关闭前==。也就是说，在==整个浏览器未关闭前==，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。
需要注意的有以下几点：

- 页面刷新不会消除数据，(==只有当全部关闭index.html和从其内部打开的所有页面或者直接关闭浏览器，才可以消除sessionStorage中的数据==。)
- 只有在当前页面打开的链接，才可以访sessionStorage的数据
- 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据



### 3. cookie，session，token
### 4. 加载网页的全部过程
### 5. preflight请求

#### 什么是预检请求

由于浏览器拦截跨域请求的方法是：请求可以发送到服务器，但是返回的响应被浏览器拦截了，所以这种情况可能会对数据库进行修改，为了避免这种情况的发生，浏览器必须先使用`options`发起一次预检请求来询问服务器是否允许该跨域请求。通常`preflight`请求不需要用户自己去管理和干预，它的发出的响应都是由浏览器和服务器自动管理的。

#### 什么时候发送

只要==不满足以下任意一点==就会发送

1. 请求方法是`get`,`post`或`head`
2. 请求头只能包含`Accept` ,`Accept-Language` ,`Content-Language` ,`Content-Type`, `DPR`, `Downlink` ,`Save-Data`, `Viewport-Width` ,`Width`
3. Content-Type只能包含以下三种类型 `text/plain` `multipart/form-data` `application/x-www-form-urlencoded`
4. `XMLHttpRequestUpload`对象没有注册任何事件监听器
5. 请求中不能使用`ReadableStream`对象

对于常规的开发来说，主要的限制在前三条。最常见的场景是==设置了自定义请求头==和==`Content-Type`类型不在支持的范围以内==。

#### 发送的`options`请求内容

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```
其中，关键字段是`Origin`，表示请求来自哪个源。除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#### 服务器的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是==没有任何CORS相关的头信息字段==。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他CORS相关字段如下。

```http
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）Access-Control-Allow-Methods**

==该字段必需==，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，==返回的是所有支持的方法，而不单是浏览器请求的那个方法==。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，==不限于浏览器在"预检"中请求的字段==。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

```http
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin`字段是==每次回应都必定包含的==。

### 6. SEO优化
### 7. 跨域问题

#### 什么是跨域问题？

#### 怎么解决跨域问题？

1. 跨域资源共享CORS

   [阮一峰 跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

2. jsonp

3. websocket

## 五、Vue
### 1. 生命周期钩子函数 

