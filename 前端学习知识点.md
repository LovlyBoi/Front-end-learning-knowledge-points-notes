# 前端学习知识点

## 一、HTML

  ### 1. H5新标签

1. header 表示头部
2. nav 表示导航
3. article 表示文章主体
4. aside 表示和页面主要内容有关，但不是页面的一部分，经常表示一个相关链接
5. footer 表示底部
6. audio 音频标签
7. video 视频标签

h5新标签提供了更好的语义化支持

  ### 2. meta标签

meta：文档级元数据元素，提供有关页面的元信息（meta-information），比如针对搜索引擎和更新频度的描述和关键词

#### 属性

- name：

  - description 用于网站内容的描述，告诉搜索引擎网站的主要内容

    ```html
    <meta name="description" content="网站的描述">
    ```

  - keywords 告诉搜索引擎网页的关键字

    ```html
    <meta name="keywords" content="php中文网">
    ```

  - viewport 指定移动端的窗口

    ```html
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    ```

- http-equiv：

  - content-type 设定网页字符集

    ```html
    <meta charset="utf-8">
    ```

  - X-UA-Compatible 用于告知浏览器以何种版本来渲染页面

    ```html
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    ```

  - cache-control 指导浏览器如何缓存某个响应以及缓存多长时间

    ```html
    <meta http-equiv="cache-control" content="no-cache">
    ```

    - no-cache: 先发送请求，与服务器确认该资源是否被更改，如果未被更改，则使用缓存。
    - no-store: 不允许缓存，每次都要去服务器上，下载完整的响应。（安全措施）
    - public : 缓存所有响应，但并非必须。因为max-age也可以做到相同效果
    - private : 只为单个用户缓存，因此不允许任何中继进行缓存。（比如说CDN就不允许缓存private的响应）
    - maxage : 表示当前请求开始，该响应在多久内能被缓存和重用，而不去服务器重新请求。例如：max-age=60表示响应可以再缓存和重用 60 秒。

## 二、CSS

### 1. 选择器

#### 选择器列表

将多个选择器使用逗号组合起来形成选择器列表，当选择器列表中有选择器无效（语法错误）时，整个列表都会被忽略

#### 选择器种类

1. 类型选择器

   ```css
   h1{}
   ```

2. 类选择器

   ```css
   .box1{}   
   div.box1{}   /*div中所有box1类*/
   ```

3. ID选择器

   ```css
   #btn{}
   ```

4. 属性选择器

   ```css
   [title='mytitle']
   ```

5. 关系选择器

   1. 后代选择器

      ```css
      ul li{}
      ```

   2. 子代选择器

      ```css
      article > p{}
      ```

   3. 相邻兄弟选择器

      ```css
      h1 + p{}
      ```

   4. 通用兄弟选择器

      ```css
      h1 ~ p{}
      ```

6. 伪类选择器

   1. :checked

      ```css
      input:checked{}   /*选择所有被选中的input标签*/
      ```

   2. :default

      ```css
      input:default{}   /*选择所有默认的input*/
      ```

   3. :focus

      ```css
      input:focus{}   /*选择获得焦点的input*/
      ```

   4. :disabled

      ```css
      input:disabled{}   /*选择所有禁用的input*/
      ```

   5. :enabled

      ```css
      input:enabled{}   /*选择所有启用的input*/
      ```

   6. :first-child

      ```css
      p:first-child{}   /*选择每一组p标签中第一个p标签（第一个子代元素必须是p，否则不匹配）*/
      ```

   7. :first-of-type

      ```css
      p:first-of-type{}   /*选择一组p标签兄弟中的第一个p标签（不需要考虑父元素的第一个子代元素）*/
      ```

   8. :nth-child
   
7. 伪元素选择器

   1. ::before

      ```css
      div::before{
      	content: ">";   /*创建一个伪元素，作为该元素的第一个子元素，默认为行内元素*/
      }
      ```

   2. ::after

      ```css
      div::after{
        content: "<";   /*创建一个伪元素，作为已选中元素的最后一个子元素，默认是行内元素*/
      }
      ```

8. 通配选择器

   ```css
   *{
   	/*选择所有元素*/
   }
   ```

   

### 2. 选择器权重

不同类型的选择器有不同的分数值，把这些分数相加就得到特定选择器的权重，然后就可以进行匹配。

一个选择器的优先级可以说是由四个部分相加 (分量)，可以认为是个十百千 — 四位数的四个位数：

1. **千位**： 如果声明在 [`style`](https://developer.mozilla.org/zh-CN/docs/Web/HTML/Global_attributes#attr-style) 的属性（内联样式）则该位得一分。这样的声明没有选择器，所以它得分总是1000。
2. **百位**： 选择器中包含ID选择器则该位得一分。
3. **十位**： 选择器中包含类选择器、属性选择器或者伪类则该位得一分。
4. **个位**：选择器中包含元素、伪元素选择器则该位得一分。

> 通用选择器 (`*`)，组合符 (`+`, `>`, `~`, ' ')，和否定伪类 (`:not`) 不会影响优先级。
>
> 在进行计算时不允许进行进位，例如，20 个类选择器仅仅意味着 20 个十位，而不能视为 两个百位，也就是说，无论多少个类选择器的权重叠加，都不会超过一个 ID 选择器。

!important 能覆盖所有规则

### 3. 盒模型

#### 盒模型

组成一个块级盒模型需要：

- Content box：这个区域是用来显示内容，大小可以通过设置 [`width`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/width) 和 [`height`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/height)。
- Padding box：包围在内容区域外部的空白区域； 大小通过 [`padding`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/padding) 相关属性设置。
- Border box：边框盒包裹内容和内边距。大小通过 [`border`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/border) 相关属性设置。
- Margin box：这是最外面的区域，是盒子和其他元素之间的空白区域。大小通过 [`margin`](https://developer.mozilla.org/zh-CN/docs/Web/CSS/margin) 相关属性设置。

当设置width和height时，设置的是content box，增加内边距、边框和外边距不会影响内容区域的尺寸，但是会增加元素框的总尺寸。

元素的总宽度应该这样计算：

元素总宽度 = 宽度 + 左内边距 + 右内边距 + 左边框 + 右边框 + 左外边距 + 右外边距

元素的总高度应该这样计算：

元素总高度 = 高度 + 上内边距 + 下内边距 + 上边框 + 下边框 + 上外边距 + 下外边距

#### 外边距

外边距是盒子周围一圈看不到的空间。它会把其他元素从盒子旁边推开。 外边距属性值可以为正也可以为负。设置负值会导致和其他内容重叠。

##### 外边距折叠

如果有两个外边距相接的元素，这些外边距将==合并为一个外边距==，即最大的单个外边距的大小。

#### 内联盒子

对于内联盒子（内敛元素），设置==宽度和高度会被忽略==，但==内边距，外边距和边框生效==，但它们不会改变其他内容与内联盒子的关系，因此==内边距和边框会与段落中的其他单词重叠==。解决方法：display: inline-block;

### 4. BFC，.clearfix清除塌陷

块级格式化上下文（Block Formatting Context, BFC），是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。

#### 创建BFC

- 根元素（html）
- 浮动元素（元素的float不是none）
- 绝对定位元素（display: absolute或display: fixed）
- 行内块元素（display: inline-block）
- `display` 值为 `flow-root` 的元素
- 表格单元格（元素的 `display` 为 `table-cell`，HTML表格单元格默认为该值）
- 表格标题（元素的`display`为 `table-caption`，HTML表格标题默认为该值）
- 匿名表格单元格元素（元素的`display`为 `table`、`table-row`、 `table-row-group`、`table-header-group`、`table-footer-group`（分别是HTML table、row、tbody、thead、tfoot 的默认属性）或 `inline-table`）
- overflow不为visible的元素
- 弹性元素（flex的直接子元素）
- 网格元素（gird的直接子元素）

#### BFC的作用

- 父元素高度塌陷

  当子元素高度大于父元素，且子元素开启浮动后，由于子元素脱离了文档流，会导致父元素高度塌陷。

  ###### 解决方法

  - 改变父元素的 `overflow` 值，开启父元素的BFC，这时父元素会变成一个迷你布局，将包含浮动的子元素

  - 开启父元素的 `display: flow-root` ，它可以创建无副作用的 BFC。关于值 `flow-root`的这个名字，当你明白你实际上是在创建一个行为类似于根元素 （浏览器中的`<html>`元素） 的东西时，就能发现这个名字的意义了——即==创建一个上下文，里面将进行 [flow layout](https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flow_Layout)==（也就是文档流布局）。

  - 添加一个新的空元素把父元素撑开（会占用仅有的两个伪元素）

    ```css
    .clearfix::before,   /*在前面加一个空的伪元素，解决父子外边距合并问题*/
    .clearfix::after{
        content:'';
        display:table;
        clear:both;   /*清除浮动影响，确保这个空元素能在浮动元素下面*/
    }
    ```

- 外边距合并

  两个相邻的盒子的外边距会合并在一起（①父元素有margin-top，子元素也有margin-top，且没有边框，这时两个margin-top重叠在一起，会产生合并,导致子元素的外边距无法在父元素内，父子元素会贴在一起；②两个兄弟元素之间的外边距重叠在一起,取最大值）

  ###### 解决方法

  - 给父元素加上边框（会改变盒子大小）
  - 开启父元素BFC
  - 使用clearfix类（在父元素前面加一个空的伪元素来隔开两个外边距）

### 5. 浮动
### 6. 定位
### 7. em，rem，以及rem进行移动端布局

#### em和rem

- em：font-size-of-the-element，em作为font-size的单位时，其代表父元素的字体大小，em作为其他属性单位时，代表自身字体大小
- rem：font-size-of-the-root-element，rem作用于非根元素时，相对于根元素字体大小；rem作用于根元素字体大小时，相对于其出初始字体大小

#### rem布局

由于100vw转换为设计图里的750px，假设有一个30px需要转换，可以得出30px / 750px = (x)vw / 100vw，即x = (100 / 750) * 30 ，然而每次需要换算时都进行`(100 / 设计图宽度) * 需要转换的px`实在是太麻烦了，所以使用rem来确定转换关系。

##### 思路

==设置根元素大小为一个固定数值 * (100vw / 设计图宽度)，这样我们在进行计算时只需要除以那个固定数值（通常是100）即可（单位是rem）==，这时1rem = 固定数值个设计图里的px（100px）

rem布局首先要操控根元素字体大小

```css
html{
    font-size: calc(100*100vw/750);
}
body{
  font-size:14px; /* 在这里把字体大小校正回来 */
}
```

这里是因为很多设计稿都是基于 iPhone6 来设计的，一般都是 750px（2 倍图，iPhone6 的设备宽度为 375px）所以除以  750 是为了在 iPhone6 设备下让 1rem 等于 100px。

```css
.menu li{
    display: table-cell;
    padding: .1rem .3rem;  /* 相当于10px 30px */
}
```



### 8. 过渡，动画，关键帧
### 9. 响应式布局
### 10. flex布局
### 11. grid布局
### 12. 圣杯布局
### 13. 双飞翼布局

## 三、JS

### 1. 基本类型
### 2. null和undefined
### 3. 原型链
### 4. 闭包
### 5. 执行上下文
### 6. this指向
### 7. 继承的实现
### 8. 深拷贝和浅拷贝
### 9. 事件循环机制

### 10. ES6

#### 1. let和const
#### 2. 数组新方法
#### 3. map，set
#### 4. rest参数，扩展运算符
#### 5. Promise
#### 6. class语法糖
### 11. 异步请求
#### 1. 原生xhr对象
#### 2. axios框架

### 12. JSON

`JSON.stringify()` 方法将一个 JavaScript 对象或值转换为 JSON 字符串，如果指定了一个 replacer 函数，则可以选择性地替换值，或者指定的 replacer 是数组，则可选择性地仅包含数组指定的属性。

```js
console.log(JSON.stringify({ x: 5, y: 6 }));
// expected output: '{"x":5,"y":6}'

console.log(JSON.stringify([new Number(3), new String('false'), new Boolean(false)]));
// expected output: '[3,"false",false]'

console.log(JSON.stringify({ x: [10, undefined, function(){}, Symbol('')] }));
// expected output: '{"x":[10,null,null,null]}'

console.log(JSON.stringify(new Date(2006, 0, 2, 15, 4, 5)));
// expected output: '"2006-01-02T15:04:05.000Z"'
```

#### 语法

**JSON.stringify(value[, replacer [, space]])**

#### 参数

- `value`

  将要序列化成 一个 JSON 字符串的值。

- `replacer` 可选

  如果该参数是一个函数，则在序列化过程中，被序列化的值的每个属性都会经过该函数的转换和处理；如果该参数是一个数组，则只有包含在这个数组中的属性名才会被序列化到最终的 JSON 字符串中；如果该参数为 null 或者未提供，则对象所有的属性都会被序列化。

- `space` 可选

  指定缩进用的空白字符串，用于美化输出（pretty-print）；如果参数是个数字，它代表有多少的空格；上限为10。该值若小于1，则意味着没有空格；如果该参数为字符串（当字符串长度超过10个字母，取其前10个字母），该字符串将被作为空格；如果该参数没有提供（或者为 null），将没有空格。

#### 返回值

一个表示给定值的JSON字符串

#### 转换规则

- 转换值如果有 toJSON() 方法，该方法定义什么值将被序列化。
- 非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。
- 布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。
- `undefined`、任意的函数以及 symbol 值，在序列化过程中会被忽略（出现在非数组对象的属性值中时）或者被转换成 `null`（出现在数组中时）。函数、undefined 被单独转换时，会返回 undefined，如`JSON.stringify(function(){})` or `JSON.stringify(undefined)`.
- 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。
- 所有以 symbol 为属性键的属性都会被完全忽略掉，即便 `replacer` 参数中强制指定包含了它们。
- Date 日期调用了 toJSON() 将其转换为了 string 字符串（同Date.toISOString()），因此会被当做字符串处理。
- NaN 和 Infinity 格式的数值及 null 都会被当做 null。
- 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。

```js
JSON.stringify({});                        // '{}'
JSON.stringify(true);                      // 'true'
JSON.stringify("foo");                     // '"foo"'
JSON.stringify([1, "false", false]);       // '[1,"false",false]'
JSON.stringify({ x: 5 });                  // '{"x":5}'

JSON.stringify({x: 5, y: 6});
// '{"x":5,"y":6}'

JSON.stringify([new Number(1), new String("false"), new Boolean(false)]);
// '[1,"false",false]'

JSON.stringify({x: undefined, y: Object, z: Symbol("")});
// '{}'

JSON.stringify([undefined, Object, Symbol("")]);
// '[null,null,null]'

JSON.stringify({[Symbol("foo")]: "foo"});
// '{}'

JSON.stringify({[Symbol.for("foo")]: "foo"}, [Symbol.for("foo")]);
// '{}'
```



## 四、浏览器

### 1. **浏览器缓存**

#### 浏览器缓存机制

① 浏览器在发送请求之前，会根据请求头的`expires`和`cache-control`判断是否命中（包括是否过期）强缓存策略，如果命中，直接从缓存获取资源，并不会发送请求。如果没有命中，则进入下一步。② 没有命中强缓存规则，浏览器会发送请求，根据请求头的`last-modified`和`etag`判断是否命中协商缓存，如果命中，直接从缓存获取资源。如果没有命中，则进入下一步。③ 如果前两步都没有命中，则直接从服务端获取资源。

<img src="C:\Users\LiuZhiwen\Desktop\前端学习知识点\assets\浏览器缓存机制.jpg" alt="浏览器缓存机制" style="zoom: 33%;" />

#### 强缓存

强缓存：==不会向服务器发送请求，直接从缓存中读取数据==

强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种(暂不分析协商缓存过程)，如下：

1. 第一次请求，不存在缓存结果和缓存标识，直接向服务器发送请求
2. 存在缓存标识和缓存结果，但是已经失效，强制缓存失败，则使用协商缓存（暂不分析）
3. 存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果

强制缓存的规则：当浏览器向服务器发送请求时，服务器会==将缓存规则放入HTTP响应报文头中==返回给浏览器，控制强制缓存的字段是`Cache-Control`和`Expires`，其中，`Cache-Control`比`Expires`优先级更高

1. Expires

   Expires指定了缓存过期时间，Expires = max-age + 请求时间，需要和Last-modified结合使用。在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。

   > Expires 是 HTTP/1 的产物，受限于本地时间，如果修改了本地时间，可能会造成缓存失效。

   

2. Cache-Control

   在HTTP/1.1中，Cache-Control是最重要的规则，主要用于控制网页缓存，主要取值为：

   - public：所有内容都将被缓存（客户端和代理服务器都可缓存）
   - private：所有内容只有客户端可以缓存，`Cache-Control`的默认取值
   - no-cache：客户端缓存内容，但是是否使用缓存则需要经过**协商缓存**来验证决定
   - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
   - max-age=xxx ：缓存内容将在xxx秒后失效

   > 需要注意的是，`no-cache`这个名字有一点误导。设置了`no-cache`之后，并不是说浏览器就不再缓存数据，只是浏览器在使用缓存数据时，需要先确认一下数据是否还跟服务器保持一致，也就是协商缓存。而`no-store`才表示不会被缓存，即不使用强制缓存，也不使用协商缓存



#### 协商缓存

协商缓存就是==强制缓存失效后==，浏览器==携带缓存标识==向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要有以下两种情况：

- 协商缓存生效，返回304和Not Modified，浏览器从缓存中读取资源
- 协商缓存失效，返回200和请求结果，浏览器将请求结果重新写入缓存

Last-Modified和If-Modified-Since：

1. 浏览器首先发送一个请求，让服务器在响应头中返回请求的资源上次更新时间，就是`last-modified`，浏览器会缓存下这个时间。
2. 然后浏览器再下次请求中，请求头中带上`if-modified-since`:`[保存的last-modified的值]`。根据浏览器发送的修改时间和服务端的修改时间进行比对，一致的话代表资源没有改变，服务端返回正文为空的响应，让浏览器中缓存中读取资源，这就大大减小了请求的消耗。

由于last-modified依赖的是保存的绝对时间，还是会出现误差的情况：

1. 保存的时间是以秒为单位的，1秒内多次修改是无法捕捉到的；
2. 各机器读取到的时间不一致，就有出现误差的可能性。为了改善这个问题，提出了使用etag。

etag

`etag`是`http`协议提供的若干机制中的一种`Web`缓存验证机制，并且允许客户端进行缓存协商。生成etag常用的方法包括对资源内容使用抗碰撞散列函数，使用最近修改的时间戳的哈希值，甚至只是一个版本号。 和`last-modified`一样. - 浏览器会先发送一个请求得到`etag`的值，然后再下一次请求在`request header`中带上`if-none-match`:`[保存的etag的值]`。 - 通过发送的`etag`的值和服务端重新生成的`etag`的值进行比对，如果一致代表资源没有改变，服务端返回正文为空的响应，告诉浏览器从缓存中读取资源。

> etag能够解决last-modified的一些缺点，但是etag每次服务端生成都需要进行读写操作，而last-modified只需要读取操作，从这方面来看，etag的消耗是更大的。

二者对比 - 精确度上：`Etag`要优于`Last-Modified`。 - 优先级上：服务器校验优先考虑`Etag`。 - 性能上：`Etag`要逊于`Last-Modified`



#### 缓存存放的位置

浏览器的网络请求的Size会出现三种情况：`from memory cache(内存缓存)`、`from disk cache(磁盘缓存)`以及资源大小数值。

- from memory cache：不请求网络资源，资源在内存当中，读取快速，但是占用内存资源，且进程关闭时会释放内存
- from disk cache：不请求网络资源，资源在磁盘当中，需要进行io操作，速度慢
- 资源大小数值：从服务器下载最新资源

浏览器读取缓存的顺序为memory –> disk。



#### 用户行为对浏览器缓存的影响

1. 打开网页，地址栏输入地址： 查找 `disk cache` 中是否有匹配。如有则使用；如没有则发送网络请求。
2. 普通刷新 (F5)：因为 TAB 并没有关闭，因此 `memory cache` 是可用的，会被优先使用(如果匹配的话)。其次才是 `disk cache`。
3. 强制刷新 (Ctrl + F5)：浏览器不使用缓存，因此发送的请求头部均带有 `Cache-control:no-cache`(为了兼容，还带了 `Pragma:no-cache`),服务器直接返回 200 和最新内容。

### 2. **WebStorage**

#### webstorage

web Storage 是HTML 5引入的一个重要的功能，它可以在客户端本地存储数据，类似cookie，但其功能却比cookie强大的多。cookie的大小只有4Kb左右（浏览器不同，大小也不同），而web Storage的大小有5MB。其API提供的方法有以下几种：

```js
setItem (key, value) ——  保存数据，以键值对的方式储存信息。
getItem (key) ——  获取数据，将键值传入，即可获取到对应的value值。
removeItem (key) ——  删除单个数据，根据键值移除对应的信息。
clear () ——  删除所有的数据
key (index) —— 获取某个索引的key
```

#### localStorage

==localStorage的生命周期是永久性的==。假若使用localStorage存储数据，即使关闭浏览器，也不会让数据消失，除非主动的去删除数据，使用的方法如上所示。localStorage有length属性，可以查看其有多少条记录的数据。使用方法如下：

```js
var storage = null;
if(window.localStorage){              //判断浏览器是否支持localStorage
  storage = window.localStorage;     
  storage.setItem("name", "Rick");    //调用setItem方法，存储数据
  alert(storage.getItem("name"));     //调用getItem方法，弹框显示 name 为 Rick
  storage.removeItem("name");     		//调用removeItem方法，移除数据
  alert(storage.getItem("name"));   	//调用getItem方法，弹框显示 name 为 null
}
```

#### sessionStorage

==sessionStorage 的生命周期是在浏览器关闭前==。也就是说，在==整个浏览器未关闭前==，其数据一直都是存在的。sessionStorage也有length属性，其基本的判断和使用方法和localStorage的使用是一致的。
需要注意的有以下几点：

- 页面刷新不会消除数据，(==只有当全部关闭index.html和从其内部打开的所有页面或者直接关闭浏览器，才可以消除sessionStorage中的数据==。)
- 只有在当前页面打开的链接，才可以访sessionStorage的数据
- 使用window.open打开页面和改变localtion.href方式都可以获取到sessionStorage内部的数据



### 3. cookie，session，token
### 4. 加载网页的全部过程
### 5. preflight请求

#### 什么是预检请求

由于浏览器拦截跨域请求的方法是：请求可以发送到服务器，但是返回的响应被浏览器拦截了，所以这种情况可能会对数据库进行修改，为了避免这种情况的发生，浏览器必须先使用`options`发起一次预检请求来询问服务器是否允许该跨域请求。通常`preflight`请求不需要用户自己去管理和干预，它的发出的响应都是由浏览器和服务器自动管理的。

#### 什么时候发送

只要==不满足以下任意一点==就会发送

1. 请求方法是`get`,`post`或`head`
2. 请求头只能包含`Accept` ,`Accept-Language` ,`Content-Language` ,`Content-Type`, `DPR`, `Downlink` ,`Save-Data`, `Viewport-Width` ,`Width`
3. Content-Type只能包含以下三种类型 `text/plain` `multipart/form-data` `application/x-www-form-urlencoded`
4. `XMLHttpRequestUpload`对象没有注册任何事件监听器
5. 请求中不能使用`ReadableStream`对象

对于常规的开发来说，主要的限制在前三条。最常见的场景是==设置了自定义请求头==和==`Content-Type`类型不在支持的范围以内==。

#### 发送的`options`请求内容

```http
OPTIONS /cors HTTP/1.1
Origin: http://api.bob.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: X-Custom-Header
Host: api.alice.com
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```
其中，关键字段是`Origin`，表示请求来自哪个源。除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

#### 服务器的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

```http
HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://api.bob.com
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Content-Type: text/html; charset=utf-8
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是==没有任何CORS相关的头信息字段==。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

```
XMLHttpRequest cannot load http://api.alice.com.
Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
```

服务器回应的其他CORS相关字段如下。

```http
Access-Control-Allow-Methods: GET, POST, PUT
Access-Control-Allow-Headers: X-Custom-Header
Access-Control-Allow-Credentials: true
Access-Control-Max-Age: 1728000
```

**（1）Access-Control-Allow-Methods**

==该字段必需==，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，==返回的是所有支持的方法，而不单是浏览器请求的那个方法==。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，==不限于浏览器在"预检"中请求的字段==。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

#### 浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

```http
PUT /cors HTTP/1.1
Origin: http://api.bob.com
Host: api.alice.com
X-Custom-Header: value
Accept-Language: en-US
Connection: keep-alive
User-Agent: Mozilla/5.0...
```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

```http
Access-Control-Allow-Origin: http://api.bob.com
Content-Type: text/html; charset=utf-8
```

上面头信息中，`Access-Control-Allow-Origin`字段是==每次回应都必定包含的==。

### 6. SEO优化
### 7. 跨域问题

#### 什么是跨域问题？

#### 怎么解决跨域问题？

1. 跨域资源共享CORS

   [阮一峰 跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)

2. jsonp

3. websocket

## 五、Vue
### 1. 生命周期钩子函数 

